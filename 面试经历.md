

# 百度

## 百度一面 20201224

### 基础知识

1. 段错误是由什么引起的？该怎么调试？

   https://www.cnblogs.com/liangyc/p/11631872.html

   访问了不存在的地址、访问了只读的地址、访问了系统保护的地址、栈溢出

2. C和C++有什么不同

3. 指针和引用有什么不同

4. static的作用

### 编程题 

1. 反转链表





# 第七课

## 并查集

并查集有两个作用：

1. 判断两个元素是否属于同一个集合。 isSameSet(A,B)
2. 合并两个元素所在的集合。union(A,B)

实现并查集可以用多种方式，例如 链表、哈希表等，但如何快速地实现并查集的两个功能是设计结构时需要考虑的问题。

经典的并查集结构是通过多叉树实现的，每个节点都有一个指针指向自己的父节点，每棵树的代表节点指向自己。

查询两个节点所在树的代表节点是否相同，判断是否属于同一集合。

将一个集合的代表节点的父节点指向另一个集合的代表节点，实现集合的合并。

**注：在这里我们可以看到并查集用的树结构不是普通的树，普通的树父节点指向孩子节点，从根往下分叉，并查集的结构孩子指向父，从叶子向上汇聚**
有两点要注意的：

1. 两个集合合并时，将数量少的集合挂在数量较多的集合上效率更高
2. 当查询完一个节点之后，将他直接挂在代表节点的下面，方便下一次的查询。

**使用哈希表实现并查集示例：**

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

///并查集中存放的节点类型，存放什么都可以
class Node{
public:
    bool operator !=(Node node){
    
    }
    bool operator ==(Node node){
        
    }
};

class UnionFindSet{
public:
    UnionFindSet(vector<Node>& nodes){
        makeSets(nodes);
    }

    Node findHead(Node node){
        Node father = fatherMap[node];
        if(father!=node){
            father = findHead(father);
        }
        fatherMap[node] = father;
        return father;
    }
    
    bool isSameSet(Node a,Node b){
        return findHead(a) == findHead(b);
    }
    
    void Union(Node a,Node b){
        Node aHead = findHead(a);
        Node bHead = findHead(b);
        if(aHead!=bHead){
            int aSetSize = sizeMap[aHead];
            int bSetSize = sizeMap[bHead];
            if(aSetSize <= bSetSize){
                fatherMap[aHead] = bHead;
                sizeMap[bHead] = aSetSize+bSetSize;
            }else{
                fatherMap[bHead] = aHead;
                sizeMap[aHead] = aSetSize+bSetSize;
            }
        }
    }
private:
    unordered_map<Node,Node> fatherMap;
    unordered_map<Node,int> sizeMap;

    void makeSets(vector<Node>& nodes){
        fatherMap.clear();
        sizeMap.clear();
        for(Node node:nodes){
            fatherMap.push(node,node);
            sizeMap.put(node,1);
        }
    }
};
```

### LeetCode 200 岛屿数量

岛屿数量的经典解法是使用递归来做，与种子填充思路相同

```c++
class Solution {
public:
    void infect(vector<vector<char>>& grid,int rows,int cols,int x,int y){
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]!='1'){
            return;
        }
        grid[x][y] = '2';
        infect(grid,rows,cols,x-1,y);
        infect(grid,rows,cols,x+1,y);
        infect(grid,rows,cols,x,y-1);
        infect(grid,rows,cols,x,y+1);        
    }

    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0||grid[0].size()==0){
            return 0;
        }
        int rows = grid.size();
        int cols = grid[0].size();
        int res=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(grid[i][j]=='1'){
                    infect(grid,rows,cols,i,j);
                    res++;
                }
            }
        }
        return res;
    }
};
```

如果矩阵非常大，需要拆分成很多小矩阵再合并起来，合并的时候使用并查集来合并。



