# 面试记录

## 网易互联网 C++开发工程师 

### 一面 20201223

#### 基础知识

1. 讲讲红黑树和AVL树
2. C++中哪些数据结构使用了红黑树和AVL树，为什么不用AVL树
3. 哈希表的实现方法、解决冲突的方法、负载因子
4. 堆和栈两种数据结构

#### 编程题1 两个栈实现一个队列

#### 编程题2 LeetCode129 根到叶结点的路径和

```c++
#include <vector>
#include <iostream>
#include <math.h>
using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};
 
class Solution {
public:
    void findSum(TreeNode* root, int cur, int& sum) {
        if(root == nullptr){
            return;
        } 
        cur = cur * 10 + root->val;
        if(root->left != nullptr){
            findSum(root->left, cur, sum);
        }
        if(root->right != nullptr){ 
            findSum(root->right, cur, sum);
        }
        if(root->left == nullptr&& root->right == nullptr){
            sum += cur;
        }
    }
    
    int sumNumbers(TreeNode* root) {
        int sum = 0;
        int cur = 0;
        findSum(root, cur, sum);
        return sum;
    }
};
```
使用字符串实现
```c++
class Solution {
public:
    void Sum(TreeNode* root,string str,int& sum){
        if(root == nullptr){
            return;
        }
        str += to_string(root->val);
        
        if(root->left!=nullptr){
            Sum(root->left,str,sum);
        }
        if(root->right!=nullptr){
            Sum(root->right,str,sum);
        }
        if(root->left==nullptr&&root->right==nullptr){
            sum += stoi(str);
        }
    }

    int sumNumbers(TreeNode* root) {
        string str;
        int sum = 0;
        Sum(root,str,sum);
        return sum;
    }
};
```

#### 遇到的最大困难及经验

# 第一课

[递归] 01:05:36

[递归行为复杂度分析] 01:04:00   

[小和问题和逆序对问题] 00:25:50

## 认识时间复杂度

## 递归

1. 递归与普通的函数调用没有区别，只不过是每次调用自己，可以想想这个函数有很多副本。
2. 函数调用时会发生压栈的行为，记录父函数即将执行的指令位置及参数状态，子函数返回时，弹出要执行的指令位置及参数状态。
3. 递归最终要能够返回，要有终止的状态。

### 递归复杂度分析

T(N) = aT(N/b) + O(N^d)

上式的含义是：样本量为N时，时间复杂度为 T(N)，处理时将 N 的样本量分为 a个 N/b 的处理，各段处理完之后，需要 O(N^d) 的处理。

满足上式的情况时间复杂度为（master公式）：

1. log(b,a) > d ，复杂度为 O(N^log(b,a))
2. log(b,a) = d，复杂度为  O(N^d*logN)
3. log(b,a) < d，复杂度为  O(N^d)

### 递归实现返回数组最大值

**思路是**：将一个数组分成两段，分别得到两段的最大值，再比较返回较大的那一个。

```c++
#include <vector>
#include <iostream>
using namespace std;

int myMax(vector<int>& arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L+((R-L)>>1);
    int mL= myMax(arr,L,mid);
    int mR= myMax(arr,mid+1,R);
    return mL>mR? mL:mR;
}

int main()
{
    vector<int> arr{1,4,2,6,5,8,9,7};
    int arrMax=myMax(arr,0,arr.size()-1);
    cout<<arrMax<<endl;
    return 0;
}
```

T(N) = aT(N/b) + O(1)

log(b,a) = 1> d =0

时间复杂度：N

### 归并排序

**思路是**：将一个数组分成两段，将两段分别排序，再合并两个有序数组。

```c++
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr,int L,int mid,int R){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }

    while(p1<=mid){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }

    for(int j=L;j<=R;++j){
        arr[j]=help[j-L];
    }
}

void sortProcess(vector<int>& arr,int L,int R){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    sortProcess(arr,L,mid);
    sortProcess(arr,mid+1,R);
    merge(arr,L,mid,R);
}

void mergeSort(vector<int>& arr){
    if(arr.empty()||arr.size()==1){
        return;
    }
    sortProcess(arr,0,arr.size()-1);
}

int main()
{
    vector<int> arr{5,6,4,3,8,7,2,1};
    mergeSort(arr);
    for(int i:arr){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

**时间复杂度：** O(n*lgn)

T(N) = aT(N/b) + O(N)

log(b,a) = 1= d =1

时间复杂度：NlogN

**空间复杂度：** O(n)

#### 小和问题和逆序对问题

**LeetCode 剑指Offer 51 数组中的逆序对**

```c++
#include <vector>
#include <iostream>
using namespace std;

void merge(vector<int>& nums,int L,int mid,int R,int& ans){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        if(nums[p1]>nums[p2]){
            ans+=R-p2+1;
            help[i++]=nums[p1++];
        }else{
            help[i++]=nums[p2++];
        }
    }

    while(p1<=mid){
        help[i++]=nums[p1++];
    }
    while(p2<=R){
         help[i++]=nums[p2++];
    }

    for(int j=L;j<=R;++j){
        nums[j]=help[j-L];
    }
}

void mergeSort(vector<int>& nums,int L,int R,int& ans){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    mergeSort(nums,L,mid,ans);
    mergeSort(nums,mid+1,R,ans);
    merge(nums,L,mid,R,ans);
}

int reversePairs(vector<int>& nums) {
    if(nums.size()<=1){
        return 0;
    }
    int ans=0;
    mergeSort(nums,0,nums.size()-1,ans);
    return ans;
}

int main()
{
    vector<int> nums{7,5,6,4};
    cout<<reversePairs(nums)<<endl;
    return 0;
}
```

# 第二课

## 荷兰国旗问题

给定数字 n，将数组 nums 分成三块，小于 n，等于 n，大于 n。要求额外空间复杂度 O(1)，时间复杂度 O(n)。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}
```

## 快速排序

快速排序就是使用 partition 进行递归，每次排好锚点的位置，对大于和小于锚点的部分在进行 partition，有几点需要注意：

1. 锚点使用数组的最后一个数
2. partition可以使用原来的，也可以如下进行稍微的改进，改进的作用只是节省了一个变量，差别不大。
3. 递归的终止条件是 L>=R , L=R的情况就是大于或小于锚点的部分只有一个数，不用再排序，L>R的情况是 上一次再排好锚点以后，没有大于锚点的部分或小于锚点的部分。可举例体会。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}

vector<int> partition2(vector<int>& nums,int L,int R){
    int less=L-1;
    int more=R;

    while(L<more){
        if(nums[L]<nums[R]){
            swap(nums,++less,L++);
        }else if(nums[L]>nums[R]){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    swap(nums,more,R);

    return vector<int>{less,more};
}

void quickSort(vector<int>& nums,int L,int R){
    if(L<R){
        vector<int> board(2,0);
        //board = partition(nums,L,R,nums[R]);
        board = partition2(nums,L,R);
        quickSort(nums,L,board[0]);
        quickSort(nums,board[1],R);
    }
}

int main()
{
    vector<int> nums{1,4,2,5,7,5,3};
    quickSort(nums,0,nums.size()-1);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

在锚点选的比较好时，大于锚点和小于锚点的区域相当，

**时间复杂度：** O(n*lgn)

T(N) = 2T(N/2) + O(N)

log(b,a) = 1= d =1

时间复杂度：O(NlogN)，长期期望的复杂度

如果锚点选的不好，没有大于区域或没有小于区域，时间复杂度 O(N^2)

**额外空间复杂度：** O(logN)，划分点需要记下来

**改进方法是** 锚点随机选择，不再只用最后一个数。

```C++
#include <random>
void quickSort(vector<int>& nums,int L,int R){
    if(L>=R){
        return;
    }
    ///产生随机数
    std::mt19937 rng;
    rng.seed(random_device()());
    std::uniform_int_distribution<std::mt19937::result_type> dist(L,R);
    swap(nums,dist(rng),R);

    vector<int> board;
    board=partition(nums,L,R,nums[R]);
    quickSort(nums,L,board[0]);
    quickSort(nums,board[1],R);
}
```

打乱数据结构的两种常用方法：

1. 随机打乱
2. 哈希函数

快排使用较多的原因是 代码简洁，常数项少。归并排序要辅助数组，排好放进辅助数组后还要再赋值回去，相当于遍历两次。

工程上不使用递归函数，会改为迭代形式。

## 堆排序

**时间复杂度：** O(n*lgn)     **额外空间复杂度：** O(1)

**堆**： 完全二叉树，一般用数组表示

**大根堆**： 任何一棵子树的最大值都是其头部

**小根堆**： 任何一棵子树的最小值都是其头部

### 数组变成大根堆

以数组 2 1 3 6 0 4 为例，依次添加新节点，大值与父节点交换。

建立一个大根堆的时间复杂度 log1+log2+log3+……+log(N-1) 收敛于 N   O(N)

### 吐出数的流找中位数

用一个 大根堆 和一个 小根堆实现

### 堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

///向大根堆中添加数据
void heapInsert(vector<int>& nums,int index){
    while(nums[index]>nums[(index-1)/2]){
        swap(nums[index],nums[(index-1)/2]);
        index = (index-1)/2;
    }
}

///本来是大根堆，有一个值发生了变化，从这个值开始和子节点交换
void heapify(vector<int>& nums,int index,int heapSize){
    int left = index*2 + 1;
    while(left < heapSize){
        ///左右孩子的最大值
        int largest = left+1<heapSize && nums[left+1]>nums[left]? (left+1):left;
        ///左右孩子与节点的最大值
        largest = nums[largest]>nums[index] ? largest:index;
        if(largest == index){
            break;
        }
        swap(nums[largest],nums[index]);
        index = largest;
        left = index*2 +1;
    }
}

void heapSort(vector<int>& nums){
    if(nums.size()<2){
        return;
    }
    for(int i=0;i<nums.size();++i){
        heapInsert(nums,i);
    }
    int heapSize = nums.size();
    swap(nums[0],nums[--heapSize]);
    while(heapSize>0){
        heapify(nums,0,heapSize);
        swap(nums[0],nums[--heapSize]);
    }
}

int main()
{
    vector<int> nums{3,2,4,5,2,6,7,1};
    heapSort(nums);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

# 第三课

## 排序的稳定性

相同值在排序前后的次序是不是一致

**稳定排序**：冒泡排序稳定，往上冒的过程中，遇到相同值不交换；

​                    插入排序稳定，往前插的过程中，遇到相同值停止；

​                    选择排序不稳定，5 5 5 5 5 5 4 0 1，第一次找到最小的0与第一个5交换，破坏了稳定性；

​                    归并排序稳定，在左右合并时，如果相等先拷贝左侧数据；

​					快速排序不稳定，两个相同的比锚点大的数，第一个先会放到more区域，第二个会放到第一个前面；

​                    堆排序也不稳定，因为它是跳着换的，4 4 4 5 5，建大根堆时，第二个 4 会和第一个 5 交换。

## 工程中的综合排序算法

如果是一个很长的数组，工程上会先进行判断，数组中是基础类型还是自定义的类型。如果是基础类型，会用快排，如果是自定义的类型，会用归并排序。这里是因为稳定性的关系，基础类型没有先后，自定义类型可能有先后。

如果数组很短（<60），会用插入排序。因为数组短时，O(n^2)的劣势体现不出来，插排的常数项很低，会很快。

如果是大数组，在进行递归归并时，数组长度小于60，直接插排。

## 自定义排序算法

## 桶排序、计数排序、基数排序

1. 这三种排序方法不是基于比较的排序。与被排序的样本的实际数据状况有很大关系，所以实际中并不常使用。
2. 时间复杂度O(n)，额外空间复杂度O(n)
3. 稳定的排序

举个例子，为什么是不基于比较的排序。我有一个数组nums，已知数据范围是 0~60，进行排序，就可以利用一个 长度为61（标号为0-60）的数组，遍历 nums，在对应标号处计数，遍历一次就可以知道 nums中 各个数据的 个数。这个排序称为 **计数排序**，是 **桶排序** 的一种。

### 给定数组，求如果排序后相邻两数的最大差值，要求时间复杂度 O(n)

利用了桶的思想，但不进行桶排序。N 个数，准备 N+1 个桶。第一次遍历，找到最小值和最大值，最小值放 1 号桶，最大值放 N 号桶，最小值到最大值等分为 N+1 份，其他数放入对应的桶。肯定会有空桶，最大差值一定跨桶。

具体步骤：遍历数组，只记录每个桶的最大值和最小值。

```c++
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
using namespace std;

int bucket(int num,int size,int Min,int Max){
    return (int)((num-Min)*size/(Max-Min));
}

int maxGap(vector<int>& nums){
    if(nums.size()<2){
        return 0;
    }

    int size = nums.size();
    int Min = INT_MAX;
    int Max = INT_MIN;

    for(int i:nums){
        Min = min(Min,i);
        Max = max(Max,i);
    }

    if(Min==Max){
        return 0;
    }

    vector<bool> hasNum(size+1,false);
    vector<int> maxs(size+1,0);
    vector<int> mins(size+1,0);

    int bid = 0;
    for(int i:nums){
        bid = bucket(i,size,Min,Max);
        mins[bid] = hasNum[bid]? min(i,mins[bid]):i;
        maxs[bid] = hasNum[bid]? max(i,maxs[bid]):i;
        hasNum[bid] = true;
    }

    int res = 0;
    int lastMax = maxs[0];

    for(int i=1;i<=size;++i){
        if(hasNum[i]){
            res = max(res,mins[i]-lastMax);
            lastMax = maxs[i];
        }
    }
    return res;
}

int main()
{
    vector<int> nums{1,4,2,6,9,5};
    cout<<maxGap(nums)<<endl;
    return 0;
}
```

## 数组实现固定大小的队列和栈

**数组实现栈**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayStack{
public:
    ArrayStack(int initSize){
        if(initSize<0){
            throw "The init size is less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;
    }

    ~ArrayStack(){
        delete arr;
    }

    void push(int obj){
        if(size==arr->size()){
            throw "The stack is full";
        }
        arr->at(size++) = obj;
    }

    int pop(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(--size);
    }

    int top(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(size-1);
    }
private:
    vector<int>* arr;
    int size;
};


int main(){
    ArrayStack as(3);
    as.push(1);
    cout<<as.top()<<endl;
    as.pop();
    cout<<as.top()<<endl;
    return 0;
}
```

**数组实现队列**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayQueue{
public:
    ArrayQueue(int initSize){
        if(initSize<0){
            throw "The init size less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;   ///记录队列中的元素数量
        head = 0;  ///head指向第一个数据的位置
        tail = 0;   ///tail指向可以放数据的位置
    }

    ~ArrayQueue(){
        delete arr;
    }

    void push(int obj){
        if(size == arr->size()){
            throw "The queue is full";
        }
        arr->at(tail) = obj;
        size++;
        tail = tail==arr->size()-1 ? 0:++tail;
    }

    void pop(){
        if(size == 0){
             throw "The queue is empty";
        }
        head = head==arr->size()-1? 0:++head;
        size--;
    }

    int front(){
        if(size == 0){
             throw "The queue is empty";
        }
        return arr->at(head);
    }

private:
    vector<int>* arr;
    int head;
    int tail;
    int size;
};

int main()
{
    ArrayQueue aq(2);
    aq.push(1);
    cout<<aq.front()<<endl;
    aq.push(2);
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    return 0;
}
```

## O(1)操作返回最小值的栈

**LeetCode 剑指offer30 包含min函数的栈**

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
using namespace std;

class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        _stack.push(x);
        if(minSta.empty()){
            minSta.push(x);
        }else{
            minSta.push(::min(x,minSta.top())); ///min命名冲突，使用域作用符调用库函数min
        } 
    }
    
    void pop() {
        _stack.pop();
        minSta.pop();
    }
    
    int top() {
        return _stack.top();
    }
    
    int min() {
        return minSta.top();
    }
private:
    stack<int> _stack;
    stack<int> minSta;
};
```

## 仅用队列结构实现栈

两个队列来回倒，保持一个队列始终为空

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class MyStack {
public:
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        if(q2.empty()){
            q1.push(x);
        }else{
            q2.push(x);
        }
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q2.pop();
            return tmp;
        }
    }

    /** Get the top element. */
    int top() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q2.push(q1.front());
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q1.push(q2.front());
            q2.pop();
            return tmp;
        }
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty()&&q2.empty();
    }
private:
    queue<int> q1;
    queue<int> q2;
};
```

## 仅用栈结构实现队列

往栈1 push，从栈2 pop。与上一题的区别是，两个队列来回倒顺序不变，两个栈来回倒顺序会反过来。

栈2 空了，才能从栈1 往栈 2 拿。

```c++
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }

    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }
    }

    /** Get the front element. */
    int peek() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            return s2.top();
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            return s2.top();
        }
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty()&&s2.empty();
    }
private:
    stack<int> s1;
    stack<int> s2;
};
```

# 第四课

## 猫狗队列

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/4.png)

## 剑指Offer 29 顺时针打印矩阵 LeetCode

**做法一：**自己想的，因为遍历很有规律，往右走 -> 往下走 -> 往左走 -> 往上走，再往右走 -> ……，所以用一个类似状态机的东西，四个函数依次调用。往右走完更改上边界，往下走完更改右边界，往左走完更改下边界，往上走完更改左边界。

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


int main()
{
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    Solution s;
    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}
```

**做法二：**算法课讲的，以一个圈为单位遍历，给定圈的左上点和右下点，遍历一圈。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2,vector<int>& res){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        ///只有一行，只需要往右走
        if(x1==x2){
            for(int i=y1;i<=y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
        }else if(y1==y2){
            for(int i=x1;i<=x2;++i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }else{
            ///向右走
            for(int i=y1;i<y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
            ///向下走
            for(int i=x1;i<x2;++i){
                //cout<<matrix[i][y2]<<" ";
                res.push_back(matrix[i][y2]);
            }
            ///向左走
            for(int i=y2;i>y1;--i){
                //cout<<matrix[x2][i]<<" ";
                res.push_back(matrix[x2][i]);
            }
            ///向上走
            for(int i=x2;i>x1;--i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }
    }

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }

        vector<int> res;

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;
        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1,y1,x2,y2,res);
             ++x1;
             ++y1;
             --x2;
             --y2;
        }
        return res;
    }
};

int main(){
    Solution s;
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```



## LeetCode 旋转矩阵

**做法一：**利用上题做法一

矩阵顺时针旋转90度的思路利用上题顺时针遍历的做法。

先从 （0，0）点数字顺时针遍历，再从 第一行最后一个点 顺时针遍历，把第一次顺时针遍历的结果依次赋值给第二次。

```c++
///顺时针遍历矩阵
class Solution2 {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


////给一个矩阵、一个起点和一个数组，从起点开始顺时针把数组的数组赋值给矩阵
class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[3]++;
        down(matrix,x+1,board[0],board,index);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y] = nums[index++];
        }
        board[0]--;
        left(matrix,board[1],y-1,board,index);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[1]--;
        up(matrix,x-1,board[2],board,index);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y]= nums[index++];
        }
        board[2]++;
        right(matrix,board[3],y+1,board,index);
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return;
        }

        nums = s.spiralOrder(matrix);

        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向下走
        int index =0;
        down(matrix,0,board[0],board,index);
    }
private:
    Solution2 s;
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> nums;
};
```

**做法二：**与上题做法二思路类似，一圈一圈处理。

```c++
class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        for(int i=0;i<x2-x1;++i){
            int tmp = matrix[x1][y1+i];
            matrix[x1][y1+i]=matrix[x2-i][y1];
            matrix[x2-i][y1]=matrix[x2][y2-i];
            matrix[x2][y2-i]=matrix[x1+i][y2];
            matrix[x1+i][y2]= tmp;
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.size()<2){
            return;
        }

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;

        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1++,y1++,x2--,y2--);
        }
    }
};
```

## “之”字形打印矩阵

**做法一：**自己想的，处理思路是 横着走、竖着走二选一，左下和右上二选一，一般情况是，横走一格、左下到头、竖走一格、右上到头；轮到横走时，先看能不能横走，不能横走就竖走；轮到竖走时，看能不能竖走，不能竖走就横走。

```c++
#include <iostream>
#include <vector>

using namespace std;

void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x=0, y=0;
    cout<<matrix[0][0]<<" ";

    int rows = matrix.size();
    int cols = matrix[0].size();
    ///flag0记录上一次是横走还是竖走, true 为竖走，因为第一次要横走
    bool flag0 = true;
    ///flag1记录上一次是左下还是右上，true 为右上
    bool flag1 = true;

    while(x<rows-1||y<cols-1){
        ///先横着走、竖着走选一个
        if(flag0){
            if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }else if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }
            flag0 = false;
        }else{
            if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }else if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }
            flag0 = true;
        }
        ///再左下走和右上走选一个
        if(flag1){
            while(x+1<rows&&y-1>=0){
                cout<<matrix[++x][--y]<<" ";
            }
            flag1 = false;
        }else{
            while(x-1>=0&&y+1<cols){
                cout<<matrix[--x][++y]<<" ";
            }
            flag1 = true;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

**做法二：**视频课里讲的

​     ![之字形](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/1.png)

如图，A往右走，B往下走，A、B连线就是一条访问路径，A不能往右走时往下走，B不能往下走时往右走。

bool型变量标识每次是从A到B输出还是从B到A输出。

```c++
#include <iostream>
#include <vector>

using namespace std;

///输入两点，打印斜对角，根据bool值,true从A->B，flase从B->A
void printAB(bool& flag,vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
    if(flag){
        for(int i=x1;i<=x2;++i){
            cout<<matrix[i][y1--]<<" ";
        }
    }else{
        for(int i=x2;i>=x1;--i){
            cout<<matrix[i][y2++]<<" ";
        }
    }
    flag=!flag;
}


void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x1=0, y1=0;
    int x2=0, y2=0;
    bool flag = false;

    int rows = matrix.size();
    int cols = matrix[0].size();

    while(x1<rows||y1<cols){
        printAB(flag,matrix,x1,y1,x2,y2);
        if(y1<cols-1){
            y1++;
        }else{
            x1++;
        }

        if(x2<rows-1){
            x2++;
        }else{
            y2++;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

## 在行和列都排好序的矩阵中找是否存在数k

N*M的矩阵，时间复杂度为 O(N+M)，空间复杂度为 O(1)

```c++
#include <iostream>
#include <vector>

using namespace std;

bool ifExist(vector<vector<int>>& matrix,int k){
    int x1 = 0;
    int y1 = matrix[0].size()-1;
    
    while(x1<matrix.size()&&y1<matrix[0].size()){
        if(k == matrix[x1][y1]){
            return true;
        }else if(k < matrix[x1][y1]){
            --y1;
        }else{
            ++x1;
        }
    }

    return false;
}


int main(){
    vector<vector<int>> matrix{{0,1,2,5},{2,3,4,7},{4,4,4,8},{5,7,7,9}};
    cout<<ifExist(matrix,7)<<endl;
    cout<<ifExist(matrix,6)<<endl;
    return 0;
}
```

## 打印两个有序链表的公共部分

和merge的过程差不多，两个指针比对往后走

## LeetCode 回文链表

链表问题一般在空间复杂度上下功夫

**普通做法：**第一遍遍历链表，依次进栈；第二次遍历链表，依次与栈顶元素比对。 时间复杂度O(n)，额外空间复杂度O(n)。

或者先用快慢指针找到中点，把后半段入栈，再比较。 

**进阶：**时间复杂度O(n)，空间复杂度O(1)。

先用快慢指针找到中点，后半段翻转，分别从两头比较，比完再翻转回去。

![回文判断](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/2.jpg)

如图，编程确保奇数结点时，慢指针指向中间，偶数结点时，慢指针指向前半最哦胡一个结点。

从两头往中间比对，一端到达 null 结束

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ///输入有效性判断
        if(head == nullptr || head->next == nullptr){
            return true;
        }
        ///定义快慢指针
        ListNode* slow = head;
        ListNode* fast = head;

        ///经过while的处理会发生两种情况
        ///奇数个结点：slow指向正中间，fast指向尾结点
        ///偶数个结点：slow指向前边部分最后一个结点，fast指向尾结点前一个结点
        while(fast!=nullptr&&fast->next != nullptr&&fast->next->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        ///如果是偶数个结点的情况fast后移一位，指向尾结点
        if(fast!=nullptr&&fast->next!=nullptr){
            fast = fast->next;
        }


        ///从slow结点开始翻转链表
        ListNode* pre = slow;
        ListNode* last = slow->next;
        slow->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }

        ///从两头依次比对
        pre = head;
        last = fast;
        bool res = true;
        while(pre != nullptr&&last != nullptr){
            if(pre->val != last->val){
                res = false;
                break;
            }
            pre = pre->next;
            last = last->next;
        }

        ///再把链表翻转回来
        pre = fast;
        if(pre!=nullptr){
            last = pre->next;
        }

        pre->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }
        return res;
    }
};

int main()
{
    ListNode node1(1);
    ListNode node2(0);
    ListNode node3(3);
    ListNode node4(4);
    ListNode node5(0);
    ListNode node6(1);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;

    Solution s;
    cout<<s.isPalindrome(&node1)<<endl;

    ListNode* head = &node1;
    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## 将单向链表按某值划分为左边小、中间相等、右边大的形式

要求：保证稳定性，时间复杂度O(n)，额外空间复杂度O(1)

可以拿出来放进数组里，用快排中的 partition 类似，但partition 不具有稳定性。

**方法：**分成三个链表，小于的，等于的，大于的，再合起来

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* listPartition(ListNode* head,int num){
    if(head==nullptr){
        return head;
    }

    ListNode* sH = nullptr; //小于链表的头
    ListNode* sT = nullptr; //小于链表的尾
    ListNode* eH = nullptr; //等于链表的头
    ListNode* eT = nullptr; //等于链表的尾
    ListNode* bH = nullptr; //大于链表的头
    ListNode* bT = nullptr; //大于链表的尾

    ///注意取出一个结点时，先打断他和后继结点的链接
    ListNode* temp = nullptr; //用于遍历
    while(head!=nullptr){
        temp = head ->next;
        head->next = nullptr;

        if(head->val<num){
            if(sH == nullptr){
                sH = head;
                sT = head;
            }else{
                sT->next = head;
                sT = sT->next;
            }
        }else if(head->val==num){
            if(eH == nullptr){
                eH = head;
                eT = head;
            }else{
                eT->next = head;
                eT = eT->next;
            }
        }else{
            if(bH == nullptr){
                bH = head;
                bT = head;
            }else{
                bT->next = head;
                bT = bT->next;
            }
        }
        head=temp;
    }

    if(sT!=nullptr){
        sT->next = eH;
        eT = eT ==nullptr? sT:eT;
    }

    if(eT!=nullptr){
        eT->next =bH;
    }
    return sH!=nullptr? sH:(eH!=nullptr?eH:bH);
}

int main()
{
    ListNode node1(9);
    ListNode node2(4);
    ListNode node3(5);
    ListNode node4(8);
    ListNode node5(2);
    ListNode node6(5);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;


    ListNode* head =listPartition(&node1,5);

    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## LeetCode138 复制带随机指针的链表

下面的两个方法思路相同

**使用哈希表的方法**

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};


class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*> map;
        Node* cur = head;

        ///先遍历结点，记录在哈希表中
        while(cur!=nullptr){
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        
        cur = head;
        while(cur != nullptr){
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        
        return map[head];
    }
};
```

**不使用哈希表的方法**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr){
            return head;
        }
        Node* cur = head;
        Node* next = nullptr;
        
        ///复制一份结点出来接在当前结点后面
        while(cur != nullptr){
            next = cur->next;
            cur->next = new Node(cur->val);
            cur->next->next = next;
            cur = next;
        }
        
        ///第二次遍历，构建random链接
        cur = head;
        Node* curCopy = nullptr;
        while(cur!=nullptr){
            curCopy = cur->next;
            curCopy->random = cur->random!=nullptr? cur->random->next:nullptr;
            cur = cur->next->next;
        }
        
        ///恢复链表
        Node* res = head->next;
        
        cur = head;
        while(cur!=nullptr){
            curCopy = cur->next;
            cur->next = cur->next->next;
            curCopy->next = cur->next == nullptr? nullptr:cur->next->next;
            cur = cur->next;
        }
        return res;
    }
};
```

 ## LeetCode 链表相交

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/3.png)

### 判断单链表是否有环

**方法一：使用哈希表**

遍历结点，存入哈希表，判断之前有没有出现过该结点。

**方法二：快慢指针**

如果有环，当快指针比慢指针多走一个环的长度时，二者相遇；

此时，快指针回到头结点，快慢指针每次都走一个，会在入环结点相遇。总长减环长等于总长减环长。

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ///返回链表入环点
    ListNode *detectCycle(ListNode *head) {
        if(head==nullptr||head->next==nullptr||head->next->next==nullptr){
            return nullptr;
        }
        ListNode* slow=head->next;
        ListNode* fast=head->next->next;

        while(slow!=fast){
            if(fast->next==nullptr||fast->next->next==nullptr){
                return nullptr;
            }
            fast = fast->next->next;
            slow = slow->next;
        }

        fast = head;
        while(fast!=slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }

    ///如果都无环返回相交点
    ListNode* noLoop(ListNode* head1,ListNode* head2){
        if(head1==nullptr||head2==nullptr){
            return nullptr;
        }
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        int n = 0;
        while(cur1->next!=nullptr){
            n++;
            cur1 = cur1->next;
        }
        while(cur2->next!=nullptr){
            n--;
            cur2 = cur2->next;
        }
        if(cur1!=cur2){
            return nullptr;
        }
        cur1 = head1;
        cur2 = head2;
        while(n>0){
            cur1 = cur1->next;
            n--;
        }
        while(n<0){
            cur2 = cur2->next;
            n++;
        }
        while(cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        return cur1;
    }
    ///如果都有环返回相交点
    ListNode* bothLoop(ListNode* head1,ListNode* head2,ListNode* loop1,ListNode* loop2){
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        ///如果在环前相交
        if(loop1 == loop2){
            int n=0;
            while(cur1!=loop1){
                n++;
                cur1 = cur1->next;
            }
            
            while(cur2!=loop2){
                n--;
                cur2 = cur2->next;
            }
            
            cur1 = head1;
            cur2 = head2;
            while(n>0){
                cur1 = cur1->next;
                n--;
            }
            while(n<0){
                cur2 = cur2->next;
                n++;
            }
            while(cur1!=cur2){
                cur1 = cur1->next;
                cur2 = cur2->next;
            }
            return cur1;
        }else{
            cur1 = loop1->next;
            while(cur1!=loop1){
                if(cur1 == loop2){
                    return loop1;
                }
                cur1=cur1->next;
            }
            return nullptr;
        }
    }

    ListNode* getIntersectionNode(ListNode* head1,ListNode* head2){
        if(head1 == nullptr||head2 == nullptr){
            return nullptr;
        }

        ListNode* loop1 = detectCycle(head1);
        ListNode* loop2 = detectCycle(head2);

        if(loop1 == nullptr&&loop2 == nullptr){
            return noLoop(head1,head2);
        }
        if(loop1 !=nullptr&&head2!=nullptr){
            return bothLoop(head1,head2,loop1,loop2);
        }
        return nullptr;
    }
};

```

# 第五课

## 二叉树的遍历

### 递归

三种递归方式的代码除了打印的位置不同，其他都相同。

本质上他们访问结点的顺序相同，每个结点会访问3次，分别对应三种顺序的遍历。

先序：先打印根节点，再打印左子树，再打印右子树。

#### 先序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    void preorder(TreeNode* root,vector<int>& v){
        if(root==nullptr){
            return;
        }
        v.push_back(root->val);
        preorder(root->left,v);
        preorder(root->right,v);
    }
    
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        preorder(root,res);
        return res;
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void inorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        inorder(root->left,v);
        v.push_back(root->val);
        inorder(root->right,v);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        inorder(root,res);
        return res;
    }
};
```

#### 后序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void postorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        postorder(root->left,v);
        postorder(root->right,v);
        v.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        postorder(root,res);
        return res;
    }
};
```

### 迭代

#### 先序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            res.push_back(root->val);
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
        }
        return res;    
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        
        stack<TreeNode*> treeStack;
        
        while(!treeStack.empty()||root!=nullptr){
            if(root!=nullptr){
                treeStack.push(root);
                root = root->left;
            }else{
                root = treeStack.top();
                treeStack.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }    
        return res;
    }
};
```

#### 后序

用两个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        stack<int> help;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            help.push(root->val);
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
        }
        
        while(!help.empty()){
            res.push_back(help.top());
            help.pop();
        }
        
        return res;
    }
};
```

用一个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        TreeNode* c= nullptr;
        
        while(!treeStack.empty()){
            c = treeStack.top();
            if(c->left!=nullptr&&root!=c->left&&root!=c->right){
                treeStack.push(c->left);
            }else if(c->right!=nullptr&&root!=c->right){
                treeStack.push(c->right);
            }else{
                res.push_back(treeStack.top()->val);
                treeStack.pop();
                root = c;
            }
        }

        return res;
    }
};
```

## 二叉树中的后继结点与前驱结点

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/5.png)

如果结点有右子树，这个结点就是一个根节点，左->根->右，后继结点就是右子树的最左结点

如果没有右子树，那它的角色就是某棵左树的最后一个结点，他要找这棵左树的根，找是别人左孩子的祖先结点。

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *parent;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* getLeftMost(TreeNode* node){
    if(node == nullptr){
        return nullptr;
    }
    while(node->left!=nullptr){
        node=node->left;
    }
    return node;
}

TreeNode* getSuccessorNode(TreeNode* node){
    if(node == nullptr){
        return node;
    }
    if(node->right != nullptr){
        return getLeftMost(node->right);
    }else{
        TreeNode* parent = node->parent;
        while(parent!=nullptr && parent->left != node){
            node = parent;
            parent = node->parent;
        }
        return parent;
    }
}
```

## LeetCode297 二叉树序列化与反序列化

先序遍历的方式

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == nullptr){
            return "#!";
        }
        string res = to_string(root->val) + "!";
        res += serialize(root->left);
        res += serialize(root->right);
        return res;
    }

    TreeNode* reconPreOrder(queue<string>& queue){
        string value = queue.front();
        queue.pop();
        if(value == "#"){
            return nullptr;
        }
        TreeNode* head = new TreeNode(stoi(value));
        head->left = reconPreOrder(queue);
        head->right = reconPreOrder(queue);
        return head;
    }
    
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        regex re("!");
        vector<string> v(sregex_token_iterator(data.begin(),data.end(),re,-1),sregex_token_iterator());
        
        queue<string> queue;
        for(const string& s:v){
            queue.push(s);
        }
        
        return reconPreOrder(queue);
    }
};

```

## LeetCode110 平衡二叉树

**第一版：**

返回每个结点的高度及是否平衡

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        pair<int,bool> depR = depth(root->right);

        if(abs(depL.first-depR.first)<=1&&depL.second == true&&depR.second == true){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

**第二版：**

不必知道最终树的高度，如果判断出来左子树或右子树不平衡，直接返回

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        
        if(depL.second == false){
            return pair<int,bool>(0,false);
        }
        
        pair<int,bool> depR = depth(root->right);
        
        if(depR.second == false){
            return pair<int,bool>(0,false);
        }

        if(abs(depL.first-depR.first)<=1){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

## LeetCode 98 搜索二叉树

**使用左右子树依次判断再返回的方式**

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    ///返回是否为二叉搜索树，最小值，最大值
    pair<bool,vector<int>> isValid(TreeNode* root){
        if(root == nullptr){
            return pair<bool,vector<int>>(true,{INT_MAX,INT_MIN});
        }
        pair<bool,vector<int>> left = isValid(root->left);
        if(left.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        pair<bool,vector<int>> right = isValid(root->right);
        if(right.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        if((root->left!=nullptr&&left.second[1]>=root->val)||(root->right!=nullptr&&right.second[0]<=root->val)){
            return pair<bool,vector<int>>(false,{0,0});
        }

        return pair<bool,vector<int>>(true,{min(left.second[0],root->val),max(right.second[1],root->val)});
    }

    bool isValidBST(TreeNode* root) {
        return isValid(root).first;
    }
};
```

**使用判断中序遍历是否升序的方式**

待完成

## LeetCode 958 二叉树的完全性验证

```c++
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        queue<TreeNode*> treeQueue;
        ///flag，标记，之后只能是叶节点
        bool leaf = false;
        TreeNode* l = nullptr;
        TreeNode* r = nullptr;
        treeQueue.push(root);
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            l = root->left;
            r = root->right;
            if((leaf&&(l!=nullptr||r!=nullptr))||(l==nullptr&&r!=nullptr)){
                return false;
            }
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
                leaf = true;
            }
        }
        return true;
    }
};
```

## LeetCode 222 完全二叉树的节点个数

**自己想的：**与判断完全二叉树思路相同，知道之后都是叶子节点以后就不用判断了。

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr){
            return 0;
        }
        queue<TreeNode*> treeQueue;
        treeQueue.push(root);
        
        int res = 0;
        
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            res++;
            TreeNode* l = root->left;
            TreeNode* r = root->right;
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
               res += treeQueue.size();
               break;
            }
        }
        return res;
    }
};
```

# 第六课

## 哈希函数与哈希表

### 哈希函数

**性质**

1. 输入域无穷大
2. 输出域有穷尽
3. 输入参数一定，返回值也确定
4. 输入不一样，输出可能一样（哈希碰撞）
5. 离散型 -> 分布均匀

**其它性质**

1. 输入有规律，输出没规律，否则无法均匀

2. 输出的结果在S域上，用输出结果对 m 取模，结果会在 0~m-1上均匀分布

   如果需要很多个哈希函数，可以用一个哈希函数改出来，并且互相独立。

   改的方法是，假如某哈希函数会得到一个结果h，h为16字节数据，把h分为 **高8字节h1** 和**低8位字节h2**则可通过以下方式得到互相独立的哈希函数：

   h1 + h2

   h1 + 2*h2

   h1 + 3*h2

   ……

   其实，16字节的每个字节之间都是互相独立的。

### 哈希表

哈希表的经典结构，假如哈希表一上来给你分配17的内存空间，这时你向哈希表中存入 key1，通过哈希函数得到对应的哈希值，哈希值模 17 得到 0~16 的值，放入对应的位置，这样一直放，可能会出现冲突，冲突后就往后挂，形成类似链表的结构（java中是红黑树）。根据哈希表的性质，我们可以认为 0~16 每个位置之后挂的 节点基本是相当的。后面挂的越多，查找的效率就越低，所以当挂到一定数量时，需要扩大哈希表。假如我扩到104，这时候我需要把哈希表中所有的数都重新求一遍哈希值，对104取模。扩容的代价，因为是成倍扩容，所以是 logN的复杂度，不仅如此，还可以离线扩容，我还往老结构中存，在线下把数据转移（JVM的托管）。有很多加速技巧，所以说 哈希表增删改查为 O(1)。

### 大数据问题

有1000T的字符串找相同字符串

1. 有多台机器处理吗？如果有1000台，可以对字符串求哈希函数再对1000取模，把字符串分散到1000台机器上。因为哈希函数有相同的输入一定有相同的输出，不同的输入均匀分布的特点。

### 设计RandomPoll结构

```c++
/*设计一种结构，在该结构中有如下三个功能：
 * 1.insert(key):将某个key加入到该结构
 * 2.delete(key):将原本在结构中的某个key移除
 * 3.getRandom():等概率随机返回结构中的任何一个key
 * 要求:insert、delete和getRandom方法的时间复杂度都是O(1) 
*/

/*设计思路:使用两个哈希表
 *1.insert(key):哈希表1存入 key + 编号(这是第几个插入的数，第一个为0，依次递增);
 *  哈希表2存入 编号 + key
 *2.getRandom():使用随机数函数在 0-最后一个编号 中产生随机数，利用哈希表2返回一个key
 *3.delete(key):在哈希表1和哈希表2中删除对应的key;删除后 0-最后一个编号中出现空缺，影响 getRandom(),
 *  把最后一个编号的 key 放到空缺的位置。
 */
```









   

   


