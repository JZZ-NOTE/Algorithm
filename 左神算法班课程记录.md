# 第一课

[递归] 01:05:36

[递归行为复杂度分析] 01:04:00   

[小和问题和逆序对问题] 00:25:50

## 认识时间复杂度

## 递归

1. 递归与普通的函数调用没有区别，只不过是每次调用的子函数相同。
2. 函数调用时会发生压栈的行为，记录父函数即将执行的指令位置及参数状态，子函数返回时，弹出要执行的指令位置及参数状态。
3. 递归最终要能够返回，要有终止的状态。

### 递归复杂度分析

T(N) = aT(N/b) + O(N^d)

上式的含义是：样本量为N时，时间复杂度为 T(N)，处理时将 N 的样本量分为 a个 N/b 的处理，各段处理完之后，需要 O(N^d) 的处理。

满足上式的情况时间复杂度为（master公式）：

1. log(b,a) > d ，复杂度为 O(N^log(b,a))
2. log(b,a) = d，复杂度为  O(N^d*logN)
3. log(b,a) < d，复杂度为  O(N^d)

### 递归实现返回数组最大值

**思路是**：将一个数组分成两段，分别得到两段的最大值，再比较返回较大的那一个。

```c++
#include <vector>
#include <iostream>
using namespace std;

int myMax(vector<int>& arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L+((R-L)>>1);
    int mL= myMax(arr,L,mid);
    int mR= myMax(arr,mid+1,R);
    return mL>mR? mL:mR;
}

int main()
{
    vector<int> arr{1,4,2,6,5,8,9,7};
    int arrMax=myMax(arr,0,arr.size()-1);
    cout<<arrMax<<endl;
    return 0;
}
```

T(N) = aT(N/b) + O(1)

log(b,a) = 1> d =0

时间复杂度：N

### 归并排序

**思路是**：将一个数组分成两段，将两段分别排序，再合并两个有序数组。

```c++
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr,int L,int mid,int R){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }

    while(p1<=mid){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }

    for(int j=L;j<=R;++j){
        arr[j]=help[j-L];
    }
}

void sortProcess(vector<int>& arr,int L,int R){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    sortProcess(arr,L,mid);
    sortProcess(arr,mid+1,R);
    merge(arr,L,mid,R);
}

void mergeSort(vector<int>& arr){
    if(arr.empty()||arr.size()==1){
        return;
    }
    sortProcess(arr,0,arr.size()-1);
}

int main()
{
    vector<int> arr{5,6,4,3,8,7,2,1};
    mergeSort(arr);
    for(int i:arr){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

**时间复杂度：** O(n*lgn)

T(N) = aT(N/b) + O(N)

log(b,a) = 1= d =1

时间复杂度：NlogN

**空间复杂度：** O(n)

#### 小和问题和逆序对问题

**LeetCode 剑指Offer 51 数组中的逆序对**

```c++
#include <vector>
#include <iostream>
using namespace std;

void merge(vector<int>& nums,int L,int mid,int R,int& ans){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        if(nums[p1]>nums[p2]){
            ans+=R-p2+1;
            help[i++]=nums[p1++];
        }else{
            help[i++]=nums[p2++];
        }
    }

    while(p1<=mid){
        help[i++]=nums[p1++];
    }
    while(p2<=R){
         help[i++]=nums[p2++];
    }

    for(int j=L;j<=R;++j){
        nums[j]=help[j-L];
    }
}

void mergeSort(vector<int>& nums,int L,int R,int& ans){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    mergeSort(nums,L,mid,ans);
    mergeSort(nums,mid+1,R,ans);
    merge(nums,L,mid,R,ans);
}

int reversePairs(vector<int>& nums) {
    if(nums.size()<=1){
        return 0;
    }
    int ans=0;
    mergeSort(nums,0,nums.size()-1,ans);
    return ans;
}

int main()
{
    vector<int> nums{7,5,6,4};
    cout<<reversePairs(nums)<<endl;
    return 0;
}
```

# 第二课

## 荷兰国旗问题

给定数字 n，将数组 nums 分成三块，小于 n，等于 n，大于 n。要求额外空间复杂度 O(1)，时间复杂度 O(n)。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}
```

## 快速排序

快速排序就是使用 partition 进行递归，每次排好锚点的位置，对大于和小于锚点的部分在进行 partition，有几点需要注意：

1. 锚点使用数组的最后一个数
2. partition可以使用原来的，也可以如下进行稍微的改进，改进的作用只是节省了一个变量，差别不大。
3. 递归的终止条件是 L>=R , L=R的情况就是大于或小于锚点的部分只有一个数，不用再排序，L>R的情况是 上一次再排好锚点以后，没有大于锚点的部分或小于锚点的部分。可举例体会。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}

vector<int> partition2(vector<int>& nums,int L,int R){
    int less=L-1;
    int more=R;

    while(L<more){
        if(nums[L]<nums[R]){
            swap(nums,++less,L++);
        }else if(nums[L]>nums[R]){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    swap(nums,more,R);

    return vector<int>{less,more};
}

void quickSort(vector<int>& nums,int L,int R){
    if(L<R){
        vector<int> board(2,0);
        //board = partition(nums,L,R,nums[R]);
        board = partition2(nums,L,R);
        quickSort(nums,L,board[0]);
        quickSort(nums,board[1],R);
    }
}

int main()
{
    vector<int> nums{1,4,2,5,7,5,3};
    quickSort(nums,0,nums.size()-1);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

在锚点选的比较好时，大于锚点和小于锚点的区域相当，

**时间复杂度：** O(n*lgn)

T(N) = 2T(N/2) + O(N)

log(b,a) = 1= d =1

时间复杂度：O(NlogN)，长期期望的复杂度

如果锚点选的不好，没有大于区域或没有小于区域，时间复杂度 O(N^2)

**额外空间复杂度：** O(logN)，划分点需要记下来

**改进方法是** 锚点随机选择，不再只用最后一个数。

```C++
#include <random>
void quickSort(vector<int>& nums,int L,int R){
    if(L>=R){
        return;
    }
    ///产生随机数
    std::mt19937 rng;
    rng.seed(random_device()());
    std::uniform_int_distribution<std::mt19937::result_type> dist(L,R);
    swap(nums,dist(rng),R);

    vector<int> board;
    board=partition(nums,L,R,nums[R]);
    quickSort(nums,L,board[0]);
    quickSort(nums,board[1],R);
}
```

打乱数据结构的两种常用方法：

1. 随机打乱
2. 哈希函数

快排使用较多的原因是 代码简洁，常数项少。归并排序要辅助数组，排好放进辅助数组后还要再赋值回去，相当于遍历两次。

工程上不使用递归函数，会改为迭代形式。

## 堆排序

**时间复杂度：** O(n*lgn)     **额外空间复杂度：** O(1)

**堆**： 完全二叉树，一般用数组表示

**大根堆**： 任何一棵子树的最大值都是其头部

**小根堆**： 任何一棵子树的最小值都是其头部

### 数组变成大根堆

以数组 2 1 3 6 0 4 为例，依次添加新节点，大值与父节点交换。

建立一个大根堆的时间复杂度 log1+log2+log3+……+log(N-1) 收敛于 N   O(N)

### 吐出数的流找中位数

用一个 大根堆 和一个 小根堆实现

### 堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

///向大根堆中添加数据
void heapInsert(vector<int>& nums,int index){
    while(nums[index]>nums[(index-1)/2]){
        swap(nums[index],nums[(index-1)/2]);
        index = (index-1)/2;
    }
}

///本来是大根堆，有一个值发生了变化，从这个值开始和子节点交换
void heapify(vector<int>& nums,int index,int heapSize){
    int left = index*2 + 1;
    while(left < heapSize){
        ///左右孩子的最大值
        int largest = left+1<heapSize && nums[left+1]>nums[left]? (left+1):left;
        ///左右孩子与节点的最大值
        largest = nums[largest]>nums[index] ? largest:index;
        if(largest == index){
            break;
        }
        swap(nums[largest],nums[index]);
        index = largest;
        left = index*2 +1;
    }
}

void heapSort(vector<int>& nums){
    if(nums.size()<2){
        return;
    }
    for(int i=0;i<nums.size();++i){
        heapInsert(nums,i);
    }
    int heapSize = nums.size();
    swap(nums[0],nums[--heapSize]);
    while(heapSize>0){
        heapify(nums,0,heapSize);
        swap(nums[0],nums[--heapSize]);
    }
}

int main()
{
    vector<int> nums{3,2,4,5,2,6,7,1};
    heapSort(nums);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

# 第三课

## 排序的稳定性

相同值在排序前后的次序是不是一致

**稳定排序**：冒泡排序稳定，往上冒的过程中，遇到相同值不交换；

​                    插入排序稳定，往前插的过程中，遇到相同值停止；

​                    选择排序不稳定，5 5 5 5 5 5 4 0 1，第一次找到最小的0与第一个5交换，破坏了稳定性；

​                    归并排序稳定，在左右合并时，如果相等先拷贝左侧数据；

​					快速排序不稳定，两个相同的比锚点大的数，第一个先会放到more区域，第二个会放到第一个前面；

​                    堆排序也不稳定，因为它是跳着换的，4 4 4 5 5，建大根堆时，第二个 4 会和第一个 5 交换。

## 工程中的综合排序算法

如果是一个很长的数组，工程上会先进行判断，数组中是基础类型还是自定义的类型。如果是基础类型，会用快排，如果是自定义的类型，会用归并排序。这里是因为稳定性的关系，基础类型没有先后，自定义类型可能有先后。

如果数组很短（<60），会用插入排序。因为数组短时，O(n^2)的劣势体现不出来，插排的常数项很低，会很快。

如果是大数组，在进行递归归并时，数组长度小于60，直接插排。

## 自定义排序算法

## 桶排序、计数排序、基数排序

1. 这三种排序方法不是基于比较的排序。与被排序的样本的实际数据状况有很大关系，所以实际中并不常使用。
2. 时间复杂度O(n)，额外空间复杂度O(n)
3. 稳定的排序

举个例子，为什么是不基于比较的排序。我有一个数组nums，已知数据范围是 0~60，进行排序，就可以利用一个 长度为61（标号为0-60）的数组，遍历 nums，在对应标号处计数，遍历一次就可以知道 nums中 各个数据的 个数。这个排序称为 **计数排序**，是 **桶排序** 的一种。

### 给定数组，求如果排序后相邻两数的最大差值，要求时间复杂度 O(n)

利用了桶的思想，但不进行桶排序。N 个数，准备 N+1 个桶。第一次遍历，找到最小值和最大值，最小值放 1 号桶，最大值放 N 号桶，最小值到最大值等分为 N+1 份，其他数放入对应的桶。肯定会有空桶，最大差值一定跨桶。

具体步骤：遍历数组，只记录每个桶的最大值和最小值。

```c++
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
using namespace std;

int bucket(int num,int size,int Min,int Max){
    return (int)((num-Min)*size/(Max-Min));
}

int maxGap(vector<int>& nums){
    if(nums.size()<2){
        return 0;
    }

    int size = nums.size();
    int Min = INT_MAX;
    int Max = INT_MIN;

    for(int i:nums){
        Min = min(Min,i);
        Max = max(Max,i);
    }

    if(Min==Max){
        return 0;
    }

    vector<bool> hasNum(size+1,false);
    vector<int> maxs(size+1,0);
    vector<int> mins(size+1,0);

    int bid = 0;
    for(int i:nums){
        bid = bucket(i,size,Min,Max);
        mins[bid] = hasNum[bid]? min(i,mins[bid]):i;
        maxs[bid] = hasNum[bid]? max(i,maxs[bid]):i;
        hasNum[bid] = true;
    }

    int res = 0;
    int lastMax = maxs[0];

    for(int i=1;i<=size;++i){
        if(hasNum[i]){
            res = max(res,mins[i]-lastMax);
            lastMax = maxs[i];
        }
    }
    return res;
}

int main()
{
    vector<int> nums{1,4,2,6,9,5};
    cout<<maxGap(nums)<<endl;
    return 0;
}
```

## 数组实现固定大小的队列和栈

**数组实现栈**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayStack{
public:
    ArrayStack(int initSize){
        if(initSize<0){
            throw "The init size is less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;
    }

    ~ArrayStack(){
        delete arr;
    }

    void push(int obj){
        if(size==arr->size()){
            throw "The stack is full";
        }
        arr->at(size++) = obj;
    }

    int pop(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(--size);
    }

    int top(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(size-1);
    }
private:
    vector<int>* arr;
    int size;
};


int main(){
    ArrayStack as(3);
    as.push(1);
    cout<<as.top()<<endl;
    as.pop();
    cout<<as.top()<<endl;
    return 0;
}
```

**数组实现队列**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayQueue{
public:
    ArrayQueue(int initSize){
        if(initSize<0){
            throw "The init size less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;   ///记录队列中的元素数量
        head = 0;  ///head指向第一个数据的位置
        tail = 0;   ///tail指向可以放数据的位置
    }

    ~ArrayQueue(){
        delete arr;
    }

    void push(int obj){
        if(size == arr->size()){
            throw "The queue is full";
        }
        arr->at(tail) = obj;
        size++;
        tail = tail==arr->size()-1 ? 0:++tail;
    }

    void pop(){
        if(size == 0){
             throw "The queue is empty";
        }
        head = head==arr->size()-1? 0:++head;
        size--;
    }

    int front(){
        if(size == 0){
             throw "The queue is empty";
        }
        return arr->at(head);
    }

private:
    vector<int>* arr;
    int head;
    int tail;
    int size;
};

int main()
{
    ArrayQueue aq(2);
    aq.push(1);
    cout<<aq.front()<<endl;
    aq.push(2);
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    return 0;
}
```

## O(1)操作返回最小值的栈

**LeetCode 剑指offer30 包含min函数的栈**

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
using namespace std;

class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        _stack.push(x);
        if(minSta.empty()){
            minSta.push(x);
        }else{
            minSta.push(::min(x,minSta.top())); ///min命名冲突，使用域作用符调用库函数min
        } 
    }
    
    void pop() {
        _stack.pop();
        minSta.pop();
    }
    
    int top() {
        return _stack.top();
    }
    
    int min() {
        return minSta.top();
    }
private:
    stack<int> _stack;
    stack<int> minSta;
};
```

## 仅用队列结构实现栈

两个队列来回倒，保持一个队列始终为空

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class MyStack {
public:
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        if(q2.empty()){
            q1.push(x);
        }else{
            q2.push(x);
        }
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q2.pop();
            return tmp;
        }
    }

    /** Get the top element. */
    int top() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q2.push(q1.front());
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q1.push(q2.front());
            q2.pop();
            return tmp;
        }
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty()&&q2.empty();
    }
private:
    queue<int> q1;
    queue<int> q2;
};
```

## 仅用栈结构实现队列

往栈1 push，从栈2 pop。与上一题的区别是，两个队列来回倒顺序不变，两个栈来回倒顺序会反过来。

栈2 空了，才能从栈1 往栈 2 拿。

```c++
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }

    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }
    }

    /** Get the front element. */
    int peek() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            return s2.top();
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            return s2.top();
        }
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty()&&s2.empty();
    }
private:
    stack<int> s1;
    stack<int> s2;
};
```

# 第四课

## 猫狗队列

## 剑指Offer 29 顺时针打印矩阵 LeetCode

**做法一：**自己想的，因为遍历很有规律，往右走 -> 往下走 -> 往左走 -> 往上走，再往右走 -> ……，所以用一个类似状态机的东西，四个函数依次调用。往右走完更改上边界，往下走完更改右边界，往左走完更改下边界，往上走完更改左边界。

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


int main()
{
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    Solution s;
    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}
```

**做法二：**算法课讲的，以一个圈为单位遍历，给定圈的左上点和右下点，遍历一圈。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2,vector<int>& res){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        ///只有一行，只需要往右走
        if(x1==x2){
            for(int i=y1;i<=y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
        }else if(y1==y2){
            for(int i=x1;i<=x2;++i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }else{
            ///向右走
            for(int i=y1;i<y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
            ///向下走
            for(int i=x1;i<x2;++i){
                //cout<<matrix[i][y2]<<" ";
                res.push_back(matrix[i][y2]);
            }
            ///向左走
            for(int i=y2;i>y1;--i){
                //cout<<matrix[x2][i]<<" ";
                res.push_back(matrix[x2][i]);
            }
            ///向上走
            for(int i=x2;i>x1;--i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }
    }

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }

        vector<int> res;

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;
        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1,y1,x2,y2,res);
             ++x1;
             ++y1;
             --x2;
             --y2;
        }
        return res;
    }
};

int main(){
    Solution s;
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```



## LeetCode 旋转矩阵

**做法一：**利用上题做法一

矩阵顺时针旋转90度的思路利用上题顺时针遍历的做法。

先从 （0，0）点数字顺时针遍历，再从 第一行最后一个点 顺时针遍历，把第一次顺时针遍历的结果依次赋值给第二次。

```c++
///顺时针遍历矩阵
class Solution2 {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


////给一个矩阵、一个起点和一个数组，从起点开始顺时针把数组的数组赋值给矩阵
class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[3]++;
        down(matrix,x+1,board[0],board,index);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y] = nums[index++];
        }
        board[0]--;
        left(matrix,board[1],y-1,board,index);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[1]--;
        up(matrix,x-1,board[2],board,index);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y]= nums[index++];
        }
        board[2]++;
        right(matrix,board[3],y+1,board,index);
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return;
        }

        nums = s.spiralOrder(matrix);

        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向下走
        int index =0;
        down(matrix,0,board[0],board,index);
    }
private:
    Solution2 s;
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> nums;
};
```

**做法二：**与上题做法二思路类似，一圈一圈处理。

```c++
class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        for(int i=0;i<x2-x1;++i){
            int tmp = matrix[x1][y1+i];
            matrix[x1][y1+i]=matrix[x2-i][y1];
            matrix[x2-i][y1]=matrix[x2][y2-i];
            matrix[x2][y2-i]=matrix[x1+i][y2];
            matrix[x1+i][y2]= tmp;
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.size()<2){
            return;
        }

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;

        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1++,y1++,x2--,y2--);
        }
    }
};
```

## “之”字形打印矩阵

**做法一：**自己想的，处理思路是 横着走、竖着走二选一，左下和右上二选一，一般情况是，横走一格、左下到头、竖走一格、右上到头；轮到横走时，先看能不能横走，不能横走就竖走；轮到竖走时，看能不能竖走，不能竖走就横走。

```c++
#include <iostream>
#include <vector>

using namespace std;

void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x=0, y=0;
    cout<<matrix[0][0]<<" ";

    int rows = matrix.size();
    int cols = matrix[0].size();
    ///flag0记录上一次是横走还是竖走, true 为竖走，因为第一次要横走
    bool flag0 = true;
    ///flag1记录上一次是左下还是右上，true 为右上
    bool flag1 = true;

    while(x<rows-1||y<cols-1){
        ///先横着走、竖着走选一个
        if(flag0){
            if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }else if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }
            flag0 = false;
        }else{
            if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }else if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }
            flag0 = true;
        }
        ///再左下走和右上走选一个
        if(flag1){
            while(x+1<rows&&y-1>=0){
                cout<<matrix[++x][--y]<<" ";
            }
            flag1 = false;
        }else{
            while(x-1>=0&&y+1<cols){
                cout<<matrix[--x][++y]<<" ";
            }
            flag1 = true;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

**做法二：**视频课里讲的

​     ![之字形](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/1.png)

如图，A往右走，B往下走，A、B连线就是一条访问路径，A不能往右走时往下走，B不能往下走时往右走。

bool型变量标识每次是从A到B输出还是从B到A输出。

```c++
#include <iostream>
#include <vector>

using namespace std;

///输入两点，打印斜对角，根据bool值,true从A->B，flase从B->A
void printAB(bool& flag,vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
    if(flag){
        for(int i=x1;i<=x2;++i){
            cout<<matrix[i][y1--]<<" ";
        }
    }else{
        for(int i=x2;i>=x1;--i){
            cout<<matrix[i][y2++]<<" ";
        }
    }
    flag=!flag;
}


void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x1=0, y1=0;
    int x2=0, y2=0;
    bool flag = false;

    int rows = matrix.size();
    int cols = matrix[0].size();

    while(x1<rows||y1<cols){
        printAB(flag,matrix,x1,y1,x2,y2);
        if(y1<cols-1){
            y1++;
        }else{
            x1++;
        }

        if(x2<rows-1){
            x2++;
        }else{
            y2++;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

## 在行和列都排好序的矩阵中找是否存在数k

N*M的矩阵，时间复杂度为 O(N+M)，空间复杂度为 O(1)

```c++
#include <iostream>
#include <vector>

using namespace std;

bool ifExist(vector<vector<int>>& matrix,int k){
    int x1 = 0;
    int y1 = matrix[0].size()-1;
    
    while(x1<matrix.size()&&y1<matrix[0].size()){
        if(k == matrix[x1][y1]){
            return true;
        }else if(k < matrix[x1][y1]){
            --y1;
        }else{
            ++x1;
        }
    }

    return false;
}


int main(){
    vector<vector<int>> matrix{{0,1,2,5},{2,3,4,7},{4,4,4,8},{5,7,7,9}};
    cout<<ifExist(matrix,7)<<endl;
    cout<<ifExist(matrix,6)<<endl;
    return 0;
}
```

## 打印两个有序链表的公共部分

和merge的过程差不多，两个指针比对往后走

## 判断一个单向链表是否为回文结构

链表问题一般在空间复杂度上下功夫

**普通做法：**第一遍遍历链表，依次进栈；第二次遍历链表，依次与栈顶元素比对。 时间复杂度O(n)，额外空间复杂度O(n)。

或者先用快慢指针找到中点，把后半段入栈，再比较。 

**进阶：**时间复杂度O(n)，空间复杂度O(1)。

先用快慢指针找到中点，后半段翻转，分别从两头比较，比完再翻转回去。













