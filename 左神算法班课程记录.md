# 第一课

[递归] 01:05:36

[递归行为复杂度分析] 01:04:00   

[小和问题和逆序对问题] 00:25:50

## 认识时间复杂度

## 递归

1. 递归与普通的函数调用没有区别，只不过是每次调用自己，可以想想这个函数有很多副本。
2. 函数调用时会发生压栈的行为，记录父函数即将执行的指令位置及参数状态，子函数返回时，弹出要执行的指令位置及参数状态。
3. 递归最终要能够返回，要有终止的状态。

### 递归复杂度分析

T(N) = aT(N/b) + O(N^d)

上式的含义是：样本量为N时，时间复杂度为 T(N)，处理时将 N 的样本量分为 a个 N/b 的处理，各段处理完之后，需要 O(N^d) 的处理。

满足上式的情况时间复杂度为（master公式）：

1. log(b,a) > d ，复杂度为 O(N^log(b,a))
2. log(b,a) = d，复杂度为  O(N^d*logN)
3. log(b,a) < d，复杂度为  O(N^d)

### 递归实现返回数组最大值

**思路是**：将一个数组分成两段，分别得到两段的最大值，再比较返回较大的那一个。

```c++
#include <vector>
#include <iostream>
using namespace std;

int myMax(vector<int>& arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L+((R-L)>>1);
    int mL= myMax(arr,L,mid);
    int mR= myMax(arr,mid+1,R);
    return mL>mR? mL:mR;
}

int main()
{
    vector<int> arr{1,4,2,6,5,8,9,7};
    int arrMax=myMax(arr,0,arr.size()-1);
    cout<<arrMax<<endl;
    return 0;
}
```

T(N) = aT(N/b) + O(1)

log(b,a) = 1> d =0

时间复杂度：N

### 归并排序

**思路是**：将一个数组分成两段，将两段分别排序，再合并两个有序数组。

```c++
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr,int L,int mid,int R){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }

    while(p1<=mid){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }

    for(int j=L;j<=R;++j){
        arr[j]=help[j-L];
    }
}

void sortProcess(vector<int>& arr,int L,int R){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    sortProcess(arr,L,mid);
    sortProcess(arr,mid+1,R);
    merge(arr,L,mid,R);
}

void mergeSort(vector<int>& arr){
    if(arr.empty()||arr.size()==1){
        return;
    }
    sortProcess(arr,0,arr.size()-1);
}

int main()
{
    vector<int> arr{5,6,4,3,8,7,2,1};
    mergeSort(arr);
    for(int i:arr){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

**时间复杂度：** O(n*lgn)

T(N) = aT(N/b) + O(N)

log(b,a) = 1= d =1

时间复杂度：NlogN

**空间复杂度：** O(n)

#### 小和问题和逆序对问题

**LeetCode 剑指Offer 51 数组中的逆序对**

```c++
#include <vector>
#include <iostream>
using namespace std;

void merge(vector<int>& nums,int L,int mid,int R,int& ans){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        if(nums[p1]>nums[p2]){
            ans+=R-p2+1;
            help[i++]=nums[p1++];
        }else{
            help[i++]=nums[p2++];
        }
    }

    while(p1<=mid){
        help[i++]=nums[p1++];
    }
    while(p2<=R){
         help[i++]=nums[p2++];
    }

    for(int j=L;j<=R;++j){
        nums[j]=help[j-L];
    }
}

void mergeSort(vector<int>& nums,int L,int R,int& ans){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    mergeSort(nums,L,mid,ans);
    mergeSort(nums,mid+1,R,ans);
    merge(nums,L,mid,R,ans);
}

int reversePairs(vector<int>& nums) {
    if(nums.size()<=1){
        return 0;
    }
    int ans=0;
    mergeSort(nums,0,nums.size()-1,ans);
    return ans;
}

int main()
{
    vector<int> nums{7,5,6,4};
    cout<<reversePairs(nums)<<endl;
    return 0;
}
```

# 第二课

## 荷兰国旗问题

给定数字 n，将数组 nums 分成三块，小于 n，等于 n，大于 n。要求额外空间复杂度 O(1)，时间复杂度 O(n)。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}
```

## 快速排序

快速排序就是使用 partition 进行递归，每次排好锚点的位置，对大于和小于锚点的部分在进行 partition，有几点需要注意：

1. 锚点使用数组的最后一个数
2. partition可以使用原来的，也可以如下进行稍微的改进，改进的作用只是节省了一个变量，差别不大。
3. 递归的终止条件是 L>=R , L=R的情况就是大于或小于锚点的部分只有一个数，不用再排序，L>R的情况是 上一次再排好锚点以后，没有大于锚点的部分或小于锚点的部分。可举例体会。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}

vector<int> partition2(vector<int>& nums,int L,int R){
    int less=L-1;
    int more=R;

    while(L<more){
        if(nums[L]<nums[R]){
            swap(nums,++less,L++);
        }else if(nums[L]>nums[R]){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    swap(nums,more,R);

    return vector<int>{less,more};
}

void quickSort(vector<int>& nums,int L,int R){
    if(L<R){
        vector<int> board(2,0);
        //board = partition(nums,L,R,nums[R]);
        board = partition2(nums,L,R);
        quickSort(nums,L,board[0]);
        quickSort(nums,board[1],R);
    }
}

int main()
{
    vector<int> nums{1,4,2,5,7,5,3};
    quickSort(nums,0,nums.size()-1);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

在锚点选的比较好时，大于锚点和小于锚点的区域相当，

**时间复杂度：** O(n*lgn)

T(N) = 2T(N/2) + O(N)

log(b,a) = 1= d =1

时间复杂度：O(NlogN)，长期期望的复杂度

如果锚点选的不好，没有大于区域或没有小于区域，时间复杂度 O(N^2)

**额外空间复杂度：** O(logN)，划分点需要记下来

**改进方法是** 锚点随机选择，不再只用最后一个数。

```C++
#include <random>
void quickSort(vector<int>& nums,int L,int R){
    if(L>=R){
        return;
    }
    ///产生随机数
    std::mt19937 rng;
    rng.seed(random_device()());
    std::uniform_int_distribution<std::mt19937::result_type> dist(L,R);
    swap(nums,dist(rng),R);

    vector<int> board;
    board=partition(nums,L,R,nums[R]);
    quickSort(nums,L,board[0]);
    quickSort(nums,board[1],R);
}
```

打乱数据结构的两种常用方法：

1. 随机打乱
2. 哈希函数

快排使用较多的原因是 代码简洁，常数项少。归并排序要辅助数组，排好放进辅助数组后还要再赋值回去，相当于遍历两次。

工程上不使用递归函数，会改为迭代形式。

## 堆排序

**时间复杂度：** O(n*lgn)     **额外空间复杂度：** O(1)

**堆**： 完全二叉树，一般用数组表示

**大根堆**： 任何一棵子树的最大值都是其头部

**小根堆**： 任何一棵子树的最小值都是其头部

### 数组变成大根堆

以数组 2 1 3 6 0 4 为例，依次添加新节点，大值与父节点交换。

建立一个大根堆的时间复杂度 log1+log2+log3+……+log(N-1) 收敛于 N   O(N)

### 吐出数的流找中位数

用一个 大根堆 和一个 小根堆实现

### 堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

///向大根堆中添加数据
void heapInsert(vector<int>& nums,int index){
    while(nums[index]>nums[(index-1)/2]){
        swap(nums[index],nums[(index-1)/2]);
        index = (index-1)/2;
    }
}

///本来是大根堆，有一个值发生了变化，从这个值开始和子节点交换
void heapify(vector<int>& nums,int index,int heapSize){
    int left = index*2 + 1;
    while(left < heapSize){
        ///左右孩子的最大值
        int largest = left+1<heapSize && nums[left+1]>nums[left]? (left+1):left;
        ///左右孩子与节点的最大值
        largest = nums[largest]>nums[index] ? largest:index;
        if(largest == index){
            break;
        }
        swap(nums[largest],nums[index]);
        index = largest;
        left = index*2 +1;
    }
}

void heapSort(vector<int>& nums){
    if(nums.size()<2){
        return;
    }
    for(int i=0;i<nums.size();++i){
        heapInsert(nums,i);
    }
    int heapSize = nums.size();
    swap(nums[0],nums[--heapSize]);
    while(heapSize>0){
        heapify(nums,0,heapSize);
        swap(nums[0],nums[--heapSize]);
    }
}

int main()
{
    vector<int> nums{3,2,4,5,2,6,7,1};
    heapSort(nums);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

# 第三课

## 排序的稳定性

相同值在排序前后的次序是不是一致

**稳定排序**：冒泡排序稳定，往上冒的过程中，遇到相同值不交换；

​                    插入排序稳定，往前插的过程中，遇到相同值停止；

​                    选择排序不稳定，5 5 5 5 5 5 4 0 1，第一次找到最小的0与第一个5交换，破坏了稳定性；

​                    归并排序稳定，在左右合并时，如果相等先拷贝左侧数据；

​					快速排序不稳定，两个相同的比锚点大的数，第一个先会放到more区域，第二个会放到第一个前面；

​                    堆排序也不稳定，因为它是跳着换的，4 4 4 5 5，建大根堆时，第二个 4 会和第一个 5 交换。

## 工程中的综合排序算法

如果是一个很长的数组，工程上会先进行判断，数组中是基础类型还是自定义的类型。如果是基础类型，会用快排，如果是自定义的类型，会用归并排序。这里是因为稳定性的关系，基础类型没有先后，自定义类型可能有先后。

如果数组很短（<60），会用插入排序。因为数组短时，O(n^2)的劣势体现不出来，插排的常数项很低，会很快。

如果是大数组，在进行递归归并时，数组长度小于60，直接插排。

## 自定义排序算法

## 桶排序、计数排序、基数排序

1. 这三种排序方法不是基于比较的排序。与被排序的样本的实际数据状况有很大关系，所以实际中并不常使用。
2. 时间复杂度O(n)，额外空间复杂度O(n)
3. 稳定的排序

举个例子，为什么是不基于比较的排序。我有一个数组nums，已知数据范围是 0~60，进行排序，就可以利用一个 长度为61（标号为0-60）的数组，遍历 nums，在对应标号处计数，遍历一次就可以知道 nums中 各个数据的 个数。这个排序称为 **计数排序**，是 **桶排序** 的一种。

### 给定数组，求如果排序后相邻两数的最大差值，要求时间复杂度 O(n)

利用了桶的思想，但不进行桶排序。N 个数，准备 N+1 个桶。第一次遍历，找到最小值和最大值，最小值放 1 号桶，最大值放 N 号桶，最小值到最大值等分为 N+1 份，其他数放入对应的桶。肯定会有空桶，最大差值一定跨桶。

具体步骤：遍历数组，只记录每个桶的最大值和最小值。

```c++
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
using namespace std;

int bucket(int num,int size,int Min,int Max){
    return (int)((num-Min)*size/(Max-Min));
}

int maxGap(vector<int>& nums){
    if(nums.size()<2){
        return 0;
    }

    int size = nums.size();
    int Min = INT_MAX;
    int Max = INT_MIN;

    for(int i:nums){
        Min = min(Min,i);
        Max = max(Max,i);
    }

    if(Min==Max){
        return 0;
    }

    vector<bool> hasNum(size+1,false);
    vector<int> maxs(size+1,0);
    vector<int> mins(size+1,0);

    int bid = 0;
    for(int i:nums){
        bid = bucket(i,size,Min,Max);
        mins[bid] = hasNum[bid]? min(i,mins[bid]):i;
        maxs[bid] = hasNum[bid]? max(i,maxs[bid]):i;
        hasNum[bid] = true;
    }

    int res = 0;
    int lastMax = maxs[0];

    for(int i=1;i<=size;++i){
        if(hasNum[i]){
            res = max(res,mins[i]-lastMax);
            lastMax = maxs[i];
        }
    }
    return res;
}

int main()
{
    vector<int> nums{1,4,2,6,9,5};
    cout<<maxGap(nums)<<endl;
    return 0;
}
```

## 数组实现固定大小的队列和栈

**数组实现栈**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayStack{
public:
    ArrayStack(int initSize){
        if(initSize<0){
            throw "The init size is less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;
    }

    ~ArrayStack(){
        delete arr;
    }

    void push(int obj){
        if(size==arr->size()){
            throw "The stack is full";
        }
        arr->at(size++) = obj;
    }

    int pop(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(--size);
    }

    int top(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(size-1);
    }
private:
    vector<int>* arr;
    int size;
};


int main(){
    ArrayStack as(3);
    as.push(1);
    cout<<as.top()<<endl;
    as.pop();
    cout<<as.top()<<endl;
    return 0;
}
```

**数组实现队列**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayQueue{
public:
    ArrayQueue(int initSize){
        if(initSize<0){
            throw "The init size less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;   ///记录队列中的元素数量
        head = 0;  ///head指向第一个数据的位置
        tail = 0;   ///tail指向可以放数据的位置
    }

    ~ArrayQueue(){
        delete arr;
    }

    void push(int obj){
        if(size == arr->size()){
            throw "The queue is full";
        }
        arr->at(tail) = obj;
        size++;
        tail = tail==arr->size()-1 ? 0:++tail;
    }

    void pop(){
        if(size == 0){
             throw "The queue is empty";
        }
        head = head==arr->size()-1? 0:++head;
        size--;
    }

    int front(){
        if(size == 0){
             throw "The queue is empty";
        }
        return arr->at(head);
    }

private:
    vector<int>* arr;
    int head;
    int tail;
    int size;
};

int main()
{
    ArrayQueue aq(2);
    aq.push(1);
    cout<<aq.front()<<endl;
    aq.push(2);
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    return 0;
}
```

## O(1)操作返回最小值的栈

**LeetCode 剑指offer30 包含min函数的栈**

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
using namespace std;

class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        _stack.push(x);
        if(minSta.empty()){
            minSta.push(x);
        }else{
            minSta.push(::min(x,minSta.top())); ///min命名冲突，使用域作用符调用库函数min
        } 
    }
    
    void pop() {
        _stack.pop();
        minSta.pop();
    }
    
    int top() {
        return _stack.top();
    }
    
    int min() {
        return minSta.top();
    }
private:
    stack<int> _stack;
    stack<int> minSta;
};
```

## 仅用队列结构实现栈

两个队列来回倒，保持一个队列始终为空

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class MyStack {
public:
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        if(q2.empty()){
            q1.push(x);
        }else{
            q2.push(x);
        }
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q2.pop();
            return tmp;
        }
    }

    /** Get the top element. */
    int top() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q2.push(q1.front());
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q1.push(q2.front());
            q2.pop();
            return tmp;
        }
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty()&&q2.empty();
    }
private:
    queue<int> q1;
    queue<int> q2;
};
```

## 仅用栈结构实现队列

往栈1 push，从栈2 pop。与上一题的区别是，两个队列来回倒顺序不变，两个栈来回倒顺序会反过来。

栈2 空了，才能从栈1 往栈 2 拿。

```c++
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }

    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }
    }

    /** Get the front element. */
    int peek() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            return s2.top();
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            return s2.top();
        }
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty()&&s2.empty();
    }
private:
    stack<int> s1;
    stack<int> s2;
};
```

# 第四课

## 猫狗队列

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/4.png)

## 剑指Offer 29 顺时针打印矩阵 LeetCode

**做法一：**自己想的，因为遍历很有规律，往右走 -> 往下走 -> 往左走 -> 往上走，再往右走 -> ……，所以用一个类似状态机的东西，四个函数依次调用。往右走完更改上边界，往下走完更改右边界，往左走完更改下边界，往上走完更改左边界。

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


int main()
{
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    Solution s;
    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}
```

**做法二：**算法课讲的，以一个圈为单位遍历，给定圈的左上点和右下点，遍历一圈。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2,vector<int>& res){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        ///只有一行，只需要往右走
        if(x1==x2){
            for(int i=y1;i<=y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
        }else if(y1==y2){
            for(int i=x1;i<=x2;++i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }else{
            ///向右走
            for(int i=y1;i<y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
            ///向下走
            for(int i=x1;i<x2;++i){
                //cout<<matrix[i][y2]<<" ";
                res.push_back(matrix[i][y2]);
            }
            ///向左走
            for(int i=y2;i>y1;--i){
                //cout<<matrix[x2][i]<<" ";
                res.push_back(matrix[x2][i]);
            }
            ///向上走
            for(int i=x2;i>x1;--i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }
    }

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }

        vector<int> res;

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;
        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1,y1,x2,y2,res);
             ++x1;
             ++y1;
             --x2;
             --y2;
        }
        return res;
    }
};

int main(){
    Solution s;
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```



## LeetCode 旋转矩阵

**做法一：**利用上题做法一

矩阵顺时针旋转90度的思路利用上题顺时针遍历的做法。

先从 （0，0）点数字顺时针遍历，再从 第一行最后一个点 顺时针遍历，把第一次顺时针遍历的结果依次赋值给第二次。

```c++
///顺时针遍历矩阵
class Solution2 {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


////给一个矩阵、一个起点和一个数组，从起点开始顺时针把数组的数组赋值给矩阵
class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[3]++;
        down(matrix,x+1,board[0],board,index);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y] = nums[index++];
        }
        board[0]--;
        left(matrix,board[1],y-1,board,index);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[1]--;
        up(matrix,x-1,board[2],board,index);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y]= nums[index++];
        }
        board[2]++;
        right(matrix,board[3],y+1,board,index);
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return;
        }

        nums = s.spiralOrder(matrix);

        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向下走
        int index =0;
        down(matrix,0,board[0],board,index);
    }
private:
    Solution2 s;
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> nums;
};
```

**做法二：**与上题做法二思路类似，一圈一圈处理。

```c++
class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        for(int i=0;i<x2-x1;++i){
            int tmp = matrix[x1][y1+i];
            matrix[x1][y1+i]=matrix[x2-i][y1];
            matrix[x2-i][y1]=matrix[x2][y2-i];
            matrix[x2][y2-i]=matrix[x1+i][y2];
            matrix[x1+i][y2]= tmp;
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.size()<2){
            return;
        }

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;

        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1++,y1++,x2--,y2--);
        }
    }
};
```

## “之”字形打印矩阵

**做法一：**自己想的，处理思路是 横着走、竖着走二选一，左下和右上二选一，一般情况是，横走一格、左下到头、竖走一格、右上到头；轮到横走时，先看能不能横走，不能横走就竖走；轮到竖走时，看能不能竖走，不能竖走就横走。

```c++
#include <iostream>
#include <vector>

using namespace std;

void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x=0, y=0;
    cout<<matrix[0][0]<<" ";

    int rows = matrix.size();
    int cols = matrix[0].size();
    ///flag0记录上一次是横走还是竖走, true 为竖走，因为第一次要横走
    bool flag0 = true;
    ///flag1记录上一次是左下还是右上，true 为右上
    bool flag1 = true;

    while(x<rows-1||y<cols-1){
        ///先横着走、竖着走选一个
        if(flag0){
            if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }else if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }
            flag0 = false;
        }else{
            if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }else if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }
            flag0 = true;
        }
        ///再左下走和右上走选一个
        if(flag1){
            while(x+1<rows&&y-1>=0){
                cout<<matrix[++x][--y]<<" ";
            }
            flag1 = false;
        }else{
            while(x-1>=0&&y+1<cols){
                cout<<matrix[--x][++y]<<" ";
            }
            flag1 = true;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

**做法二：**视频课里讲的

​     ![之字形](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/1.png)

如图，A往右走，B往下走，A、B连线就是一条访问路径，A不能往右走时往下走，B不能往下走时往右走。

bool型变量标识每次是从A到B输出还是从B到A输出。

```c++
#include <iostream>
#include <vector>

using namespace std;

///输入两点，打印斜对角，根据bool值,true从A->B，flase从B->A
void printAB(bool& flag,vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
    if(flag){
        for(int i=x1;i<=x2;++i){
            cout<<matrix[i][y1--]<<" ";
        }
    }else{
        for(int i=x2;i>=x1;--i){
            cout<<matrix[i][y2++]<<" ";
        }
    }
    flag=!flag;
}


void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x1=0, y1=0;
    int x2=0, y2=0;
    bool flag = false;

    int rows = matrix.size();
    int cols = matrix[0].size();

    while(x1<rows||y1<cols){
        printAB(flag,matrix,x1,y1,x2,y2);
        if(y1<cols-1){
            y1++;
        }else{
            x1++;
        }

        if(x2<rows-1){
            x2++;
        }else{
            y2++;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

## 在行和列都排好序的矩阵中找是否存在数k

N*M的矩阵，时间复杂度为 O(N+M)，空间复杂度为 O(1)

```c++
#include <iostream>
#include <vector>

using namespace std;

bool ifExist(vector<vector<int>>& matrix,int k){
    int x1 = 0;
    int y1 = matrix[0].size()-1;
    
    while(x1<matrix.size()&&y1<matrix[0].size()){
        if(k == matrix[x1][y1]){
            return true;
        }else if(k < matrix[x1][y1]){
            --y1;
        }else{
            ++x1;
        }
    }

    return false;
}


int main(){
    vector<vector<int>> matrix{{0,1,2,5},{2,3,4,7},{4,4,4,8},{5,7,7,9}};
    cout<<ifExist(matrix,7)<<endl;
    cout<<ifExist(matrix,6)<<endl;
    return 0;
}
```

## 打印两个有序链表的公共部分

和merge的过程差不多，两个指针比对往后走

## LeetCode 回文链表

链表问题一般在空间复杂度上下功夫

**普通做法：**第一遍遍历链表，依次进栈；第二次遍历链表，依次与栈顶元素比对。 时间复杂度O(n)，额外空间复杂度O(n)。

或者先用快慢指针找到中点，把后半段入栈，再比较。 

**进阶：**时间复杂度O(n)，空间复杂度O(1)。

先用快慢指针找到中点，后半段翻转，分别从两头比较，比完再翻转回去。

![回文判断](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/2.jpg)

如图，编程确保奇数结点时，慢指针指向中间，偶数结点时，慢指针指向前半最哦胡一个结点。

从两头往中间比对，一端到达 null 结束

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ///输入有效性判断
        if(head == nullptr || head->next == nullptr){
            return true;
        }
        ///定义快慢指针
        ListNode* slow = head;
        ListNode* fast = head;

        ///经过while的处理会发生两种情况
        ///奇数个结点：slow指向正中间，fast指向尾结点
        ///偶数个结点：slow指向前边部分最后一个结点，fast指向尾结点前一个结点
        while(fast!=nullptr&&fast->next != nullptr&&fast->next->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        ///如果是偶数个结点的情况fast后移一位，指向尾结点
        if(fast!=nullptr&&fast->next!=nullptr){
            fast = fast->next;
        }


        ///从slow结点开始翻转链表
        ListNode* pre = slow;
        ListNode* last = slow->next;
        slow->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }

        ///从两头依次比对
        pre = head;
        last = fast;
        bool res = true;
        while(pre != nullptr&&last != nullptr){
            if(pre->val != last->val){
                res = false;
                break;
            }
            pre = pre->next;
            last = last->next;
        }

        ///再把链表翻转回来
        pre = fast;
        if(pre!=nullptr){
            last = pre->next;
        }

        pre->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }
        return res;
    }
};

int main()
{
    ListNode node1(1);
    ListNode node2(0);
    ListNode node3(3);
    ListNode node4(4);
    ListNode node5(0);
    ListNode node6(1);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;

    Solution s;
    cout<<s.isPalindrome(&node1)<<endl;

    ListNode* head = &node1;
    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## 将单向链表按某值划分为左边小、中间相等、右边大的形式

要求：保证稳定性，时间复杂度O(n)，额外空间复杂度O(1)

可以拿出来放进数组里，用快排中的 partition 类似，但partition 不具有稳定性。

**方法：**分成三个链表，小于的，等于的，大于的，再合起来

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* listPartition(ListNode* head,int num){
    if(head==nullptr){
        return head;
    }

    ListNode* sH = nullptr; //小于链表的头
    ListNode* sT = nullptr; //小于链表的尾
    ListNode* eH = nullptr; //等于链表的头
    ListNode* eT = nullptr; //等于链表的尾
    ListNode* bH = nullptr; //大于链表的头
    ListNode* bT = nullptr; //大于链表的尾

    ///注意取出一个结点时，先打断他和后继结点的链接
    ListNode* temp = nullptr; //用于遍历
    while(head!=nullptr){
        temp = head ->next;
        head->next = nullptr;

        if(head->val<num){
            if(sH == nullptr){
                sH = head;
                sT = head;
            }else{
                sT->next = head;
                sT = sT->next;
            }
        }else if(head->val==num){
            if(eH == nullptr){
                eH = head;
                eT = head;
            }else{
                eT->next = head;
                eT = eT->next;
            }
        }else{
            if(bH == nullptr){
                bH = head;
                bT = head;
            }else{
                bT->next = head;
                bT = bT->next;
            }
        }
        head=temp;
    }

    if(sT!=nullptr){
        sT->next = eH;
        eT = eT ==nullptr? sT:eT;
    }

    if(eT!=nullptr){
        eT->next =bH;
    }
    return sH!=nullptr? sH:(eH!=nullptr?eH:bH);
}

int main()
{
    ListNode node1(9);
    ListNode node2(4);
    ListNode node3(5);
    ListNode node4(8);
    ListNode node5(2);
    ListNode node6(5);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;


    ListNode* head =listPartition(&node1,5);

    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## LeetCode138 复制带随机指针的链表

下面的两个方法思路相同

**使用哈希表的方法**

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};


class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*> map;
        Node* cur = head;

        ///先遍历结点，记录在哈希表中
        while(cur!=nullptr){
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        
        cur = head;
        while(cur != nullptr){
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        
        return map[head];
    }
};
```

**不使用哈希表的方法**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr){
            return head;
        }
        Node* cur = head;
        Node* next = nullptr;
        
        ///复制一份结点出来接在当前结点后面
        while(cur != nullptr){
            next = cur->next;
            cur->next = new Node(cur->val);
            cur->next->next = next;
            cur = next;
        }
        
        ///第二次遍历，构建random链接
        cur = head;
        Node* curCopy = nullptr;
        while(cur!=nullptr){
            curCopy = cur->next;
            curCopy->random = cur->random!=nullptr? cur->random->next:nullptr;
            cur = cur->next->next;
        }
        
        ///恢复链表
        Node* res = head->next;
        
        cur = head;
        while(cur!=nullptr){
            curCopy = cur->next;
            cur->next = cur->next->next;
            curCopy->next = cur->next == nullptr? nullptr:cur->next->next;
            cur = cur->next;
        }
        return res;
    }
};
```

 ## LeetCode 链表相交

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/3.png)

### 判断单链表是否有环

**方法一：使用哈希表**

遍历结点，存入哈希表，判断之前有没有出现过该结点。

**方法二：快慢指针**

如果有环，当快指针比慢指针多走一个环的长度时，二者相遇；

此时，快指针回到头结点，快慢指针每次都走一个，会在入环结点相遇。总长减环长等于总长减环长。

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ///返回链表入环点
    ListNode *detectCycle(ListNode *head) {
        if(head==nullptr||head->next==nullptr||head->next->next==nullptr){
            return nullptr;
        }
        ListNode* slow=head->next;
        ListNode* fast=head->next->next;

        while(slow!=fast){
            if(fast->next==nullptr||fast->next->next==nullptr){
                return nullptr;
            }
            fast = fast->next->next;
            slow = slow->next;
        }

        fast = head;
        while(fast!=slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }

    ///如果都无环返回相交点
    ListNode* noLoop(ListNode* head1,ListNode* head2){
        if(head1==nullptr||head2==nullptr){
            return nullptr;
        }
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        int n = 0;
        while(cur1->next!=nullptr){
            n++;
            cur1 = cur1->next;
        }
        while(cur2->next!=nullptr){
            n--;
            cur2 = cur2->next;
        }
        if(cur1!=cur2){
            return nullptr;
        }
        cur1 = head1;
        cur2 = head2;
        while(n>0){
            cur1 = cur1->next;
            n--;
        }
        while(n<0){
            cur2 = cur2->next;
            n++;
        }
        while(cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        return cur1;
    }
    ///如果都有环返回相交点
    ListNode* bothLoop(ListNode* head1,ListNode* head2,ListNode* loop1,ListNode* loop2){
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        ///如果在环前相交
        if(loop1 == loop2){
            int n=0;
            while(cur1!=loop1){
                n++;
                cur1 = cur1->next;
            }
            
            while(cur2!=loop2){
                n--;
                cur2 = cur2->next;
            }
            
            cur1 = head1;
            cur2 = head2;
            while(n>0){
                cur1 = cur1->next;
                n--;
            }
            while(n<0){
                cur2 = cur2->next;
                n++;
            }
            while(cur1!=cur2){
                cur1 = cur1->next;
                cur2 = cur2->next;
            }
            return cur1;
        }else{
            cur1 = loop1->next;
            while(cur1!=loop1){
                if(cur1 == loop2){
                    return loop1;
                }
                cur1=cur1->next;
            }
            return nullptr;
        }
    }

    ListNode* getIntersectionNode(ListNode* head1,ListNode* head2){
        if(head1 == nullptr||head2 == nullptr){
            return nullptr;
        }

        ListNode* loop1 = detectCycle(head1);
        ListNode* loop2 = detectCycle(head2);

        if(loop1 == nullptr&&loop2 == nullptr){
            return noLoop(head1,head2);
        }
        if(loop1 !=nullptr&&head2!=nullptr){
            return bothLoop(head1,head2,loop1,loop2);
        }
        return nullptr;
    }
};

```

# 第五课

## 二叉树的遍历

### 递归

三种递归方式的代码除了打印的位置不同，其他都相同。

本质上他们访问结点的顺序相同，每个结点会访问3次，分别对应三种顺序的遍历。

先序：先打印根节点，再打印左子树，再打印右子树。

#### 先序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    void preorder(TreeNode* root,vector<int>& v){
        if(root==nullptr){
            return;
        }
        v.push_back(root->val);
        preorder(root->left,v);
        preorder(root->right,v);
    }
    
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        preorder(root,res);
        return res;
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void inorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        inorder(root->left,v);
        v.push_back(root->val);
        inorder(root->right,v);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        inorder(root,res);
        return res;
    }
};
```

#### 后序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void postorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        postorder(root->left,v);
        postorder(root->right,v);
        v.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        postorder(root,res);
        return res;
    }
};
```

### 迭代

#### 先序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            res.push_back(root->val);
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
        }
        return res;    
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        
        stack<TreeNode*> treeStack;
        
        while(!treeStack.empty()||root!=nullptr){
            if(root!=nullptr){
                treeStack.push(root);
                root = root->left;
            }else{
                root = treeStack.top();
                treeStack.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }    
        return res;
    }
};
```

#### 后序

用两个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        stack<int> help;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            help.push(root->val);
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
        }
        
        while(!help.empty()){
            res.push_back(help.top());
            help.pop();
        }
        
        return res;
    }
};
```

用一个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        TreeNode* c= nullptr;
        
        while(!treeStack.empty()){
            c = treeStack.top();
            if(c->left!=nullptr&&root!=c->left&&root!=c->right){
                treeStack.push(c->left);
            }else if(c->right!=nullptr&&root!=c->right){
                treeStack.push(c->right);
            }else{
                res.push_back(treeStack.top()->val);
                treeStack.pop();
                root = c;
            }
        }

        return res;
    }
};
```

## 二叉树中的后继结点与前驱结点

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/5.png)

如果结点有右子树，这个结点就是一个根节点，左->根->右，后继结点就是右子树的最左结点

如果没有右子树，那它的角色就是某棵左树的最后一个结点，他要找这棵左树的根，找是别人左孩子的祖先结点。

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *parent;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* getLeftMost(TreeNode* node){
    if(node == nullptr){
        return nullptr;
    }
    while(node->left!=nullptr){
        node=node->left;
    }
    return node;
}

TreeNode* getSuccessorNode(TreeNode* node){
    if(node == nullptr){
        return node;
    }
    if(node->right != nullptr){
        return getLeftMost(node->right);
    }else{
        TreeNode* parent = node->parent;
        while(parent!=nullptr && parent->left != node){
            node = parent;
            parent = node->parent;
        }
        return parent;
    }
}
```

## LeetCode297 二叉树序列化与反序列化

先序遍历的方式

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == nullptr){
            return "#!";
        }
        string res = to_string(root->val) + "!";
        res += serialize(root->left);
        res += serialize(root->right);
        return res;
    }

    TreeNode* reconPreOrder(queue<string>& queue){
        string value = queue.front();
        queue.pop();
        if(value == "#"){
            return nullptr;
        }
        TreeNode* head = new TreeNode(stoi(value));
        head->left = reconPreOrder(queue);
        head->right = reconPreOrder(queue);
        return head;
    }
    
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        regex re("!");
        vector<string> v(sregex_token_iterator(data.begin(),data.end(),re,-1),sregex_token_iterator());
        
        queue<string> queue;
        for(const string& s:v){
            queue.push(s);
        }
        
        return reconPreOrder(queue);
    }
};

```

## LeetCode110 平衡二叉树

**第一版：**

返回每个结点的高度及是否平衡

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        pair<int,bool> depR = depth(root->right);

        if(abs(depL.first-depR.first)<=1&&depL.second == true&&depR.second == true){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

**第二版：**

不必知道最终树的高度，如果判断出来左子树或右子树不平衡，直接返回

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        
        if(depL.second == false){
            return pair<int,bool>(0,false);
        }
        
        pair<int,bool> depR = depth(root->right);
        
        if(depR.second == false){
            return pair<int,bool>(0,false);
        }

        if(abs(depL.first-depR.first)<=1){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

## LeetCode 98 搜索二叉树

**使用左右子树依次判断再返回的方式**

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    ///返回是否为二叉搜索树，最小值，最大值
    pair<bool,vector<int>> isValid(TreeNode* root){
        if(root == nullptr){
            return pair<bool,vector<int>>(true,{INT_MAX,INT_MIN});
        }
        pair<bool,vector<int>> left = isValid(root->left);
        if(left.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        pair<bool,vector<int>> right = isValid(root->right);
        if(right.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        if((root->left!=nullptr&&left.second[1]>=root->val)||(root->right!=nullptr&&right.second[0]<=root->val)){
            return pair<bool,vector<int>>(false,{0,0});
        }

        return pair<bool,vector<int>>(true,{min(left.second[0],root->val),max(right.second[1],root->val)});
    }

    bool isValidBST(TreeNode* root) {
        return isValid(root).first;
    }
};
```

**使用判断中序遍历是否升序的方式**

待完成

## LeetCode 958 二叉树的完全性验证

```c++
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        queue<TreeNode*> treeQueue;
        ///flag，标记，之后只能是叶节点
        bool leaf = false;
        TreeNode* l = nullptr;
        TreeNode* r = nullptr;
        treeQueue.push(root);
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            l = root->left;
            r = root->right;
            if((leaf&&(l!=nullptr||r!=nullptr))||(l==nullptr&&r!=nullptr)){
                return false;
            }
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
                leaf = true;
            }
        }
        return true;
    }
};
```

## LeetCode 222 完全二叉树的节点个数

**自己想的：**与判断完全二叉树思路相同，知道之后都是叶子节点以后就不用判断了。

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr){
            return 0;
        }
        queue<TreeNode*> treeQueue;
        treeQueue.push(root);
        
        int res = 0;
        
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            res++;
            TreeNode* l = root->left;
            TreeNode* r = root->right;
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
               res += treeQueue.size();
               break;
            }
        }
        return res;
    }
};
```

# 第六课

## 哈希函数与哈希表

### 哈希函数

**性质**

1. 输入域无穷大
2. 输出域有穷尽
3. 输入参数一定，返回值也确定
4. 输入不一样，输出可能一样（哈希碰撞）
5. 离散型 -> 分布均匀

**其它性质**

1. 输入有规律，输出没规律，否则无法均匀

2. 输出的结果在S域上，用输出结果对 m 取模，结果会在 0~m-1上均匀分布

   如果需要很多个哈希函数，可以用一个哈希函数改出来，并且互相独立。

   改的方法是，假如某哈希函数会得到一个结果h，h为16字节数据，把h分为 **高8字节h1** 和**低8位字节h2**则可通过以下方式得到互相独立的哈希函数：

   h1 + h2

   h1 + 2*h2

   h1 + 3*h2

   ……

   其实，16字节的每个字节之间都是互相独立的。

### 哈希表

哈希表的经典结构，假如哈希表一上来给你分配17的内存空间，这时你向哈希表中存入 key1，通过哈希函数得到对应的哈希值，哈希值模 17 得到 0~16 的值，放入对应的位置，这样一直放，可能会出现冲突，冲突后就往后挂，形成类似链表的结构（java中是红黑树）。根据哈希表的性质，我们可以认为 0~16 每个位置之后挂的 节点基本是相当的。后面挂的越多，查找的效率就越低，所以当挂到一定数量时，需要扩大哈希表。假如我扩到104，这时候我需要把哈希表中所有的数都重新求一遍哈希值，对104取模。扩容的代价，因为是成倍扩容，所以是 logN的复杂度，不仅如此，还可以离线扩容，我还往老结构中存，在线下把数据转移（JVM的托管）。有很多加速技巧，所以说 哈希表增删改查为 O(1)。

### 大数据问题

有1000T的字符串找相同字符串

1. 有多台机器处理吗？如果有1000台，可以对字符串求哈希函数再对1000取模，把字符串分散到1000台机器上。因为哈希函数有相同的输入一定有相同的输出，不同的输入均匀分布的特点。

### 设计RandomPoll结构

```c++
/*设计一种结构，在该结构中有如下三个功能：
 * 1.insert(key):将某个key加入到该结构
 * 2.delete(key):将原本在结构中的某个key移除
 * 3.getRandom():等概率随机返回结构中的任何一个key
 * 要求:insert、delete和getRandom方法的时间复杂度都是O(1) 
*/

/*设计思路:使用两个哈希表
 *1.insert(key):哈希表1存入 key + 编号(这是第几个插入的数，第一个为0，依次递增);
 *  哈希表2存入 编号 + key
 *2.getRandom():使用随机数函数在 0-最后一个编号 中产生随机数，利用哈希表2返回一个key
 *3.delete(key):在哈希表1和哈希表2中删除对应的key;删除后 0-最后一个编号中出现空缺，影响 getRandom(),
 *  把最后一个编号的 key 放到空缺的位置。
 */
```

### 布隆过滤器

```
/*有1000亿个url的黑名单,每个 url 64字节,给你一个 url,判断是否属于这个黑名单集合
*/

/*设计思路:
 *1.使用哈希表来做，可以准确的知道是否属于，但需要很大的空间，这么大的空间要做成哈希表放在内存中，代价很大
 *2.或者用哈希函数分流，分到多台机器上，代价也很大
 *3.布隆过滤器。布隆过滤器是一种集合，判断某个元素是否属于这个集合。布隆过滤器有失误率，某个url应该不在黑名单中，但会返回true
 *4.布隆过滤器使用 bitmap,
 *5.如果我准备了一个 m 位的 bitmap，将url的字符串通过哈希函数求得一个哈希值，模m，将bitmap对应位置置1
 *6.准备k个互相独立的哈希函数，将url的字符串通过k个哈希函数，模m，得到k个位置，k个位置可能重复，将k个位置置1，
 *7.查询的时候我按相同的方法求出 k个位置，如果k个位置都黑，则认为在黑名单中。
 *8.bitmap要长一些，否则大量数据下每个位都会变黑。bitmap越长，失误率越低。bitmap大小 m = -(n*lnp)/(ln2)^2。
 *  n为样本量，p为预期失误率
 *9.哈希函数的个数 k = ln2*(m/n)
 *10.实际失误率p =(1-e^(-n*k/m))^k
 *11.以下代码是一个位操作的示例，在C++中，可以使用数据结构 bitset
 */

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> arr(1000,0); //32000个bit位，每位都是0
    ///如果想让第 30000 bit位为1
    int index = 30000;
    int intIndex = index/32;
    int bitIndex = index%32;
    arr[intIndex] = (arr[intIndex]|(1<<bitIndex));
    return 0;
}
```

### 一致性哈希

假如我前端有几台机器，后端有3台机器 0 1 2，哈希函数可以较好地实现复杂均衡，使 0 1 2 三台机器的处理量相当。但当我增加机器时，增加到100台，需要将之前的数据重新计算，迁移过来，迁移代价较大。

一致性哈希是我求出的节点不再模3，而是将 2^64 次个数均分给3台机器，均分的方式是，给 3个节点每个节点 1000 个虚拟节点，虚拟节点负责的数据交给实际对应的机器处理。新加机器时，也给他分配 1000 个虚拟节点，虚拟节点数据的迁移对应到物理机器上。

# 第七课

## 并查集

并查集有两个作用：

1. 判断两个元素是否属于同一个集合。 isSameSet(A,B)
2. 合并两个元素所在的集合。union(A,B)

实现并查集可以用多种方式，例如 链表、哈希表等，但如何快速地实现并查集的两个功能是设计结构时需要考虑的问题。

经典的并查集结构是通过多叉树实现的，每个节点都有一个指针指向自己的父节点，每棵树的代表节点指向自己。

查询两个节点所在树的代表节点是否相同，判断是否属于同一集合。

将一个集合的代表节点的父节点指向另一个集合的代表节点，实现集合的合并。

**注：在这里我们可以看到并查集用的树结构不是普通的树，普通的树父节点指向孩子节点，从根往下分叉，并查集的结构孩子指向父，从叶子向上汇聚**
有两点要注意的：

1. 两个集合合并时，将数量少的集合挂在数量较多的集合上效率更高
2. 当查询完一个节点之后，将他直接挂在代表节点的下面，方便下一次的查询。

**使用哈希表实现并查集示例：**

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

///并查集中存放的节点类型，存放什么都可以
class Node{
public:
    bool operator !=(Node node){
    
    }
    bool operator ==(Node node){
        
    }
};

class UnionFindSet{
public:
    UnionFindSet(vector<Node>& nodes){
        makeSets(nodes);
    }

    Node findHead(Node node){
        Node father = fatherMap[node];
        if(father!=node){
            father = findHead(father);
        }
        fatherMap[node] = father;
        return father;
    }
    
    bool isSameSet(Node a,Node b){
        return findHead(a) == findHead(b);
    }
    
    void Union(Node a,Node b){
        Node aHead = findHead(a);
        Node bHead = findHead(b);
        if(aHead!=bHead){
            int aSetSize = sizeMap[aHead];
            int bSetSize = sizeMap[bHead];
            if(aSetSize <= bSetSize){
                fatherMap[aHead] = bHead;
                sizeMap[bHead] = aSetSize+bSetSize;
            }else{
                fatherMap[bHead] = aHead;
                sizeMap[aHead] = aSetSize+bSetSize;
            }
        }
    }
private:
    unordered_map<Node,Node> fatherMap;
    unordered_map<Node,int> sizeMap;

    void makeSets(vector<Node>& nodes){
        fatherMap.clear();
        sizeMap.clear();
        for(Node node:nodes){
            fatherMap.push(node,node);
            sizeMap.put(node,1);
        }
    }
};
```

### LeetCode 200 岛屿数量

岛屿数量的经典解法是使用递归来做，与种子填充思路相同

```c++
class Solution {
public:
    void infect(vector<vector<char>>& grid,int rows,int cols,int x,int y){
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]!='1'){
            return;
        }
        grid[x][y] = '2';
        infect(grid,rows,cols,x-1,y);
        infect(grid,rows,cols,x+1,y);
        infect(grid,rows,cols,x,y-1);
        infect(grid,rows,cols,x,y+1);        
    }

    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0||grid[0].size()==0){
            return 0;
        }
        int rows = grid.size();
        int cols = grid[0].size();
        int res=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(grid[i][j]=='1'){
                    infect(grid,rows,cols,i,j);
                    res++;
                }
            }
        }
        return res;
    }
};
```

如果矩阵非常大，需要拆分成很多小矩阵再合并起来，合并的时候使用并查集来合并。

## 前缀树

```c++
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct TrieNode{
    int path = 0; ///以该前缀开头的字符串个数
    int end = 0;  ///以该前缀结尾的字符串个数
    vector<TrieNode*> nexts;

    TrieNode(){
        nexts = vector<TrieNode*>(26,nullptr);
    }
};

class Trie{
public:
    Trie(){
        root = new TrieNode();
    }
    void insert(string word){
        if(word.empty()){
            return;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();i++){
            index = word[i] - 'a';
            if(node->nexts[index] == nullptr){
                node->nexts[index] = new TrieNode();
            }
            node = node->nexts[index];
            node->path++;
        }
        node->end++;
    }

    void mdelete(string word){
        if(search(word) == 0){
            return;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();++i){
            index = word[i] - 'a';
            if(--node->nexts[index]->path == 0){
                node->nexts[index] = nullptr;
                return;
            }
            node = node->nexts[index];
        }
        node->end--;
    }

    int search(string word){
        if(word.empty()){
            return 0;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();i++){
            index = word[i] - 'a';
            if(node->nexts[index] == nullptr){
                return 0;
            }
            node = node->nexts[index];
        }
        return node->end;
    }
private:
    TrieNode* root;
};


int main()
{
    string s1{"abc"};
    string s2{"abcd"};
    string s3{"bcd"};

    Trie trie;
    trie.insert(s1);
    trie.insert(s2);
    trie.insert(s3);

    cout<<"jzz"<<endl;

    cout<<trie.search(s1)<<" "<<trie.search(s2)<<" "<<trie.search(s3)<<endl;
    cout<<trie.search("ab")<<" "<<trie.search("abcde")<<" "<<trie.search(s3)<<endl;

    return 0;
}
```

# 第八课

## 贪心策略

贪心策略的证明很复杂，不要考虑

### LeetCode 179 最大数

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[](int a,int b){ return stol(to_string(a)+to_string(b))>stol(to_string(b)+to_string(a));});
        ///加这句判断是因为可能数组中都是0，只需要输出一个0
        if(nums[0]==0){
            return string{"0"};
        }

        stri ng res;
        for(int i:nums){
            res+=to_string(i);
        }
        return res;
    }
};
```

   题目的关键是找一个比较策略，比较器需要具备以下性质：

1. 传递性，如果 a.b小于等于b.a，b.c小于等于c.b，则 a.c小于等于c.a

2. 还要证明按这种方法排完的结果是最大的数，反证法，将按这种方法排好序的结果中任交换两个，结果都会变大。

### 分割数组的最小代价

哈夫曼编码问题，两个节点合起来的代价是两个节点的和，怎么代价最小

方法：使用小根堆，每次取出两个最小的合在一起，代价是它俩的和，再取最小的和这个数和。

证明比较麻烦

### LeetCode 502 IPO

方法：按花费把所有项目放小根堆，把所有比初始资金小的弹出来，按收益放进大根堆，从大根堆里弹出来一个做；做完之后资金增长，再从小根堆里弹出可以做的项目，放入大根堆，再大根堆中弹。

```c++
class Solution {
public:
    int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital) {
        ///小根堆，按花费排序
        auto cmp1 = [](pair<int,int> a,pair<int,int> b){
            return a.second>b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype (cmp1)> minCostQ(cmp1);
        ///大根堆，按利益排序
        auto cmp2 = [](pair<int,int>a,pair<int,int> b){
            return a.first<b.first;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype (cmp2)> maxProfitQ(cmp2);

        ///先把所有项目放入小根堆
        for(int i=0;i<Profits.size();i++){
            minCostQ.push(pair<int,int>(Profits[i],Capital[i]));
        }
        ///取出项目，取k次
        for(int i=0;i<k;i++){
            while(!minCostQ.empty()&&minCostQ.top().second<=W){
                maxProfitQ.push(minCostQ.top());
                minCostQ.pop();
            }
            if(maxProfitQ.empty()){
                return W;
            }
            W+=maxProfitQ.top().first;
            maxProfitQ.pop();
        }
        return W;
    }
};
```

### LeetCode 1353 最多可以参加的会议数目

### 最多可以参加的会议数目

和力扣那个题比一样

按照哪个项目早结束贪心

```c++
class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        sort(events.begin(),events.end(),[](vector<int>& a,vector<int>& b){
            return a[1]<b[1];
        });
        int res = 0;
        int end = 0;
        for(int i=0;i<events.size();i++){
            if(end<=events[i][0]){
                res++;
                end = events[i][1];
            }
        }
        return res;
    }
};
```

## 暴力递归与动态规划

**计算 n！**

```c++
long getFactorial1(int n){
    if(n==1){
        return 1;
    }
    return (long)n*getFactorial1(n-1);
}

long getFactorial2(int n){
    long res = 1;
    for(int i=1;i<=n;i++){
        res *= i;
    }
    return res;
}
```

**汉诺塔问题**

```c++
void process(int N,string from,string to,string help){
    if(N == 1){
        cout<<"Move 1 "<<from<<" to "<<to<<endl;
        return;
    }
    process(N-1,from,help,to);
    cout<<"Move "<<N<<" "<<from<<" to "<<to<<endl;
    process(N-1,help,to,from);
}

int main()
{
    int n=3;
    process(n,"A","B","C");
    return 0;
}
```

T(n) = T(n-1) + 1 + T(n-1);

等差数列

汉诺塔问题的步数是 2^n-1

### 打印一个字符串全部的子序列，包括空字符串

```c++
void process(string str,int n,string cur){
    if(n==str.size()){
        cout<<cur<<endl;
        return;
    }
    process(str,n+1,cur+str[n]);
    process(str,n+1,cur+" ");
}

int main()
{
    string str="abc";
    string cur=" ";
    process(str,0,cur);
    return 0;
}
```

### 母牛繁殖

母牛每年生一只母牛，新出生的母牛成长3年后也能每年生一只母牛，假设不会死，求N年后，母牛的数量。

f(n) = f(n-1) + f(n-3)

解释：今年的牛的数量等于 去年的牛的数量  + 3年前的牛生的牛今年会新生牛  

方法：写初始项，观察规律，分析道理

coding：可以用递归也可以从下往上写

**进阶：使用矩阵乘法可以将复杂度从 O(n) 转化为 O(logn)**

### LeetCode 64 最小路径和

**方法一：**走到根节点结算，因为有之前 **二叉树的路径和** 的经验，所以就自然这么做了。

```c++
class Solution {
public:
    void process(vector<vector<int>>& grid,int x,int y,int sum,int& min){
        if(x<grid.size()&&y<grid[0].size()){
            if(x == grid.size()-1&&y == grid[0].size()-1){
                min = sum+grid[x][y]<min? sum+grid[x][y]:min;
                return;
            }
            process(grid,x+1,y,sum+grid[x][y],min);
            process(grid,x,y+1,sum+grid[x][y],min);
        }
    }

    int minPathSum(vector<vector<int>>& grid) {
        int sum = 0;
        int min = INT_MAX;
        process(grid,0,0,sum,min);
        return min;
    }
};

int main()
{
    vector<vector<int>> grid{{6,5,3,3,7,9,6,8,1,4,8,3},{7,6,6,9,8,6,7,5,3,0,9,8},{7,0,6,9,9,0,3,7,7,9,1,7},{8,9,5,2,3,5,5,2,2,2,3,2},{0,0,8,5,0,9,6,8,0,2,9,9},{2,4,7,2,5,0,9,4,9,6,8,4},{2,3,6,6,7,0,8,0,0,6,7,3},{6,3,3,8,6,2,7,0,8,6,2,4},{6,1,0,7,0,8,1,2,3,0,0,1},{0,0,1,2,9,0,5,5,4,8,5,0},{2,2,2,1,1,5,7,9,8,7,7,8},{5,0,2,8,0,4,1,2,5,4,7,4},{5,2,1,9,3,6,1,5,0,3,8,1}};
    Solution s;
    cout<<s.minPathSum(grid)<<endl;
    return 0;
}
```

**方法二：**二叉树的递归中的另外一种做法，从左右子树得到信息，处理后返回。

```c++
class Solution {
public:
    int process(vector<vector<int>>& grid,int x,int y){
        if(x == grid.size()-1&&y == grid[0].size()-1){
            return grid[x][y];
        }
        if(x == grid.size()-1){
            return grid[x][y]+process(grid,x,y+1);
        }
        if(y == grid[0].size()-1){
            return grid[x][y]+process(grid,x+1,y);
        }
        int left = process(grid,x,y+1);
        int down = process(grid,x+1,y);
        return grid[x][y]+min(left,down);
    }

    int minPathSum(vector<vector<int>>& grid) {
        return process(grid,0,0);
    }
};

int main()
{
    vector<vector<int>> grid{{6,5,3,3,7,9,6,8,1,4,8,3},{7,6,6,9,8,6,7,5,3,0,9,8},{7,0,6,9,9,0,3,7,7,9,1,7},{8,9,5,2,3,5,5,2,2,2,3,2},{0,0,8,5,0,9,6,8,0,2,9,9},{2,4,7,2,5,0,9,4,9,6,8,4},{2,3,6,6,7,0,8,0,0,6,7,3},{6,3,3,8,6,2,7,0,8,6,2,4},{6,1,0,7,0,8,1,2,3,0,0,1},{0,0,1,2,9,0,5,5,4,8,5,0},{2,2,2,1,1,5,7,9,8,7,7,8},{5,0,2,8,0,4,1,2,5,4,7,4},{5,2,1,9,3,6,1,5,0,3,8,1}};
    Solution s;
    cout<<s.minPathSum(grid)<<endl;
    return 0;
}
```

**方法三：**动态规划，填表

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows,vector<int>(cols,0));
        dp[0][0] = grid[0][0];
        ///填第一行
        for(int i=1;i<cols;i++){
            dp[0][i] = dp[0][i-1]+grid[0][i];
        }
        ///填第一列
        for(int i=1;i<rows;i++){
            dp[i][0] = dp[i-1][0]+grid[i][0];
        }
        ///填其他位置
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                dp[i][j] = grid[i][j]+min(dp[i-1][j],dp[i][j-1]);
            }
        }

        return dp[rows-1][cols-1];
    }
};
```

### 数组元素累加

给定数组arr和一个整数aim，任意选择arr中的数字能不能累加到aim，返回true或者false

**方法一：**自己想的，思路和输出所有子序列一样，遍历到改元素时，包含该元素或不包含该元素

```c++
bool process(vector<int>& arr,int aim,int i){
    if(i==arr.size()){
        return false;
    }
    if(aim == arr[i]){
        return true;
    }
    int tmp=arr[i];
    return process(arr,aim,i+1)||process(arr,aim-tmp,i+1);
}

int main()
{
    vector<int> arr{4,5,2,1,3};
    cout<<process(arr,8,0)<<endl;
    return 0;
}
```

**方法二：**自己想的，动态规划，和视频课里讲的不一样，他讲的我没听懂。是由方法一的递归改过来的

```c++
bool process(vector<int>& arr,int aim){
    int sum = 0;
    for(int i:arr){
        sum+=i;
    }
    int rows = arr.size();
    vector<vector<bool>> dp(rows,vector<bool>(sum+1,false));
    ///填最后一行
    dp[rows-1][arr[rows-1]] = true;
    ///填其它行
    for(int i=rows-2;i>=0;i--){
        for(int j=0;j<sum;j++){
            dp[i][j] = dp[i+1][j] || (j-arr[i]>=0? dp[i+1][j-arr[i]]:false);
        }
    }
    return dp[0][aim];
}

int main()
{
    vector<int> arr{4,5,2,1,3};
    cout<<process(arr,8)<<endl;
    return 0;
}
```

# 进阶班第一课

## KMP算法
**1. 问题描述**

解决的问题与C++标准库函数中的find相同，原字符串中如果有目标字符串，返回匹配的第一个序号。

**2. 算法思路**

**重要概念：** 原字符串的next数组。一维数组，长度为原字符串的长度，内容为原字符串中每个字符匹配的前缀和后缀的最大长度。前缀和后缀的概念见下例：
以 abcabcd 为例，讨论字符d 的前缀和后缀。长度为1的前缀是a，后缀是c，不相等；长度为2的前缀是ab，后缀是bc，不相等；长度为3的前缀是abc，后缀也是abc，相等；长度为4的前缀是abca，后缀也是cabc，不相等；长度为5的前缀是abcab，后缀也是bcabc，不相等；长度为6的前缀为abcabc，后缀也为abcabc，肯定一样，没有讨论的必要，所以规定前缀不包含字符前的最后一个字符，后缀不包含第一个字符。

有了这个辅助数组，kmp算法就可以改进之前的暴力搜索，但我们也看到想得到辅助数组看起来也很复杂。

一个巧妙的地方是，后一个字符的最长匹配前后缀可以由前一个字符的最长匹配前后缀得到。

以ababcababak为例，
第0个字符a的最长匹配前后缀长度默认为 -1
第1个字符b的最长匹配前后缀长度默认为 0
字符k在它前一个字符a的基础上，a的最长匹配前缀长度为4，但a的最长前缀的下一个字符c不等于a，继续往前看c的最长前缀的下一个字符，是a，+1得到k的最长匹配前缀长度。



有了next数组，匹配过程如下例：

**i1:** 0 1 2 3 4 5 6

**s:  ** a  b k a b k s

**i2:** 0 1 2 3 4 5 6

**t: **  a  b k a b k t

s为原字符串，t为目标字符串。匹配过程开始，当 **i1 == 6，i2 == 6** 时，出现不匹配，此时不用在从头开始比，i2跳转到 **i2 == 3** 即可。

**代码**

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;
```

```cpp
///最长匹配前后缀数组
///只要记得每一个字符的最长匹配前后缀长度由它之前的字符得到就可以了
vector<int> getNextArray(string str)
{
    if(str.size()==1){
        return vector<int>{-1};
    }

    vector<int> next(str.size(),0);
    next[0]=-1;   ///默认0字符最长匹配长度为-1
    next[1]=0;    ///1字符最长匹配长度为0
    int i=2;      ///从2字符开始
    int cn=0;  ///既是前一个字符的最长前缀的长度，也是前一个字符最长前缀的后一个字符的序号，每次更新

    while(i<next.size()){
        if(str[i-1]==str[cn]){
            next[i++] = ++cn;
        }else if(cn>0){
            cn=next[cn];
        }else{
            next[i++]=0;
        }
    }
    return next;
}
```

```cpp
int getIndexOf(string s,string m){
    ///m为空，或者m的长度大于s，返回-1
    if(m.empty()||s.size()<m.size()){
        return -1;
    }
    int i1=0;  ///s从0字符开始
    int i2=0;  ///m也从0字符开始
    vector<int> next=getNextArray(m);  //得到m的next数组
    while(i1<s.size()&&i2<m.size()){   
        if(s[i1]==m[i2]){
            i1++;
            i2++;
        }else if(next[i2]==-1){
            i1++;  ///此时i2回到了最开始
        }else{
            i2=next[i2];
        }
    }
    return i2==m.size()? i1-i2:-1;
}
```

```cpp
int main()
{
    string s{"abcabcde"};
    string m{"abcd"};

    cout<<getIndexOf(s,m)<<endl;

    return 0;
}
```

### 双倍字符串

给字符串末尾添加最小的字符使其包含两个原字符串。例如，abcabc，添加abc，成为 abcabcabc ，包含两个原字符串。

**解题思路：** 本题考查 next数组，求尾元素下一个元素的 最长匹配前后缀长度

### 树的包含判断

两棵二叉树 t1 和 t2 ，判断 t2 是不是 t1 的某棵子树。返回 true 或 false

**解题思路：**把两棵树序列化，如果 s2 是 s1 的子串， t2 就是 t1 的子树

### LeetCode 459 重复的子字符串

**解题思路：** 本题也考察next数组，求尾元素下一个元素的 最长匹配前后缀长度。如果 next[str.size()] 大于str.size()-next[str.size()] ，并且可以整除 str.size()-next[str.size()] ，则返回 true。

```c++
class Solution {
public:
    bool getNextArray(string str){
        if(str.size() == 1){
            return false;
        }
        vector<int> next(str.size()+1,-1);
        next[1] = 0;
        int i = 2;
        int cn = 0;
        
        while(i<next.size()){
            if(str[i-1] == str[cn]){
                next[i++] = ++cn;
            }else if(cn>0){
                cn = next[cn];
            }else{
                next[i++] = 0;
            }
        }

        int a = next[str.size()];
        int b = str.size()-next[str.size()];

        return   a<b? false:next[str.size()]%(str.size()-next[str.size()])==0;
    }

    bool repeatedSubstringPattern(string s) {
        return getNextArray(s);
    }
};
```

### LeetCode214 最短回文串

**题目描述：** 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
**解题思路：**



