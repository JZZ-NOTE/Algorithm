# 第一课

[递归] 01:05:36

[递归行为复杂度分析] 01:04:00   

[小和问题和逆序对问题] 00:25:50

## 认识时间复杂度

## 递归

1. 递归与普通的函数调用没有区别，只不过是每次调用自己，可以想想这个函数有很多副本。
2. 函数调用时会发生压栈的行为，记录父函数即将执行的指令位置及参数状态，子函数返回时，弹出要执行的指令位置及参数状态。
3. 递归最终要能够返回，要有终止的状态。

### 递归复杂度分析

T(N) = aT(N/b) + O(N^d)

上式的含义是：样本量为N时，时间复杂度为 T(N)，处理时将 N 的样本量分为 a个 N/b 的处理，各段处理完之后，需要 O(N^d) 的处理。

满足上式的情况时间复杂度为（master公式）：

1. log(b,a) > d ，复杂度为 O(N^log(b,a))
2. log(b,a) = d，复杂度为  O(N^d*logN)
3. log(b,a) < d，复杂度为  O(N^d)

### 递归实现返回数组最大值

**思路是**：将一个数组分成两段，分别得到两段的最大值，再比较返回较大的那一个。

```c++
#include <vector>
#include <iostream>
using namespace std;

int myMax(vector<int>& arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L+((R-L)>>1);
    int mL= myMax(arr,L,mid);
    int mR= myMax(arr,mid+1,R);
    return mL>mR? mL:mR;
}

int main()
{
    vector<int> arr{1,4,2,6,5,8,9,7};
    int arrMax=myMax(arr,0,arr.size()-1);
    cout<<arrMax<<endl;
    return 0;
}
```

T(N) = aT(N/b) + O(1)

log(b,a) = 1> d =0

时间复杂度：N

### 归并排序

**思路是**：将一个数组分成两段，将两段分别排序，再合并两个有序数组。

```c++
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr,int L,int mid,int R){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }

    while(p1<=mid){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }

    for(int j=L;j<=R;++j){
        arr[j]=help[j-L];
    }
}

void sortProcess(vector<int>& arr,int L,int R){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    sortProcess(arr,L,mid);
    sortProcess(arr,mid+1,R);
    merge(arr,L,mid,R);
}

void mergeSort(vector<int>& arr){
    if(arr.empty()||arr.size()==1){
        return;
    }
    sortProcess(arr,0,arr.size()-1);
}

int main()
{
    vector<int> arr{5,6,4,3,8,7,2,1};
    mergeSort(arr);
    for(int i:arr){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

**时间复杂度：** O(n*lgn)

T(N) = aT(N/b) + O(N)

log(b,a) = 1= d =1

时间复杂度：NlogN

**空间复杂度：** O(n)

#### 小和问题和逆序对问题

**LeetCode 剑指Offer 51 数组中的逆序对**

```c++
#include <vector>
#include <iostream>
using namespace std;

void merge(vector<int>& nums,int L,int mid,int R,int& ans){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        if(nums[p1]>nums[p2]){
            ans+=R-p2+1;
            help[i++]=nums[p1++];
        }else{
            help[i++]=nums[p2++];
        }
    }

    while(p1<=mid){
        help[i++]=nums[p1++];
    }
    while(p2<=R){
         help[i++]=nums[p2++];
    }

    for(int j=L;j<=R;++j){
        nums[j]=help[j-L];
    }
}

void mergeSort(vector<int>& nums,int L,int R,int& ans){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    mergeSort(nums,L,mid,ans);
    mergeSort(nums,mid+1,R,ans);
    merge(nums,L,mid,R,ans);
}

int reversePairs(vector<int>& nums) {
    if(nums.size()<=1){
        return 0;
    }
    int ans=0;
    mergeSort(nums,0,nums.size()-1,ans);
    return ans;
}

int main()
{
    vector<int> nums{7,5,6,4};
    cout<<reversePairs(nums)<<endl;
    return 0;
}
```

# 第二课

## 荷兰国旗问题

给定数字 n，将数组 nums 分成三块，小于 n，等于 n，大于 n。要求额外空间复杂度 O(1)，时间复杂度 O(n)。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}
```

## 快速排序

快速排序就是使用 partition 进行递归，每次排好锚点的位置，对大于和小于锚点的部分在进行 partition，有几点需要注意：

1. 锚点使用数组的最后一个数
2. partition可以使用原来的，也可以如下进行稍微的改进，改进的作用只是节省了一个变量，差别不大。
3. 递归的终止条件是 L>=R , L=R的情况就是大于或小于锚点的部分只有一个数，不用再排序，L>R的情况是 上一次再排好锚点以后，没有大于锚点的部分或小于锚点的部分。可举例体会。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}

vector<int> partition2(vector<int>& nums,int L,int R){
    int less=L-1;
    int more=R;

    while(L<more){
        if(nums[L]<nums[R]){
            swap(nums,++less,L++);
        }else if(nums[L]>nums[R]){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    swap(nums,more,R);

    return vector<int>{less,more};
}

void quickSort(vector<int>& nums,int L,int R){
    if(L<R){
        vector<int> board(2,0);
        //board = partition(nums,L,R,nums[R]);
        board = partition2(nums,L,R);
        quickSort(nums,L,board[0]);
        quickSort(nums,board[1],R);
    }
}

int main()
{
    vector<int> nums{1,4,2,5,7,5,3};
    quickSort(nums,0,nums.size()-1);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

在锚点选的比较好时，大于锚点和小于锚点的区域相当，

**时间复杂度：** O(n*lgn)

T(N) = 2T(N/2) + O(N)

log(b,a) = 1= d =1

时间复杂度：O(NlogN)，长期期望的复杂度

如果锚点选的不好，没有大于区域或没有小于区域，时间复杂度 O(N^2)

**额外空间复杂度：** O(logN)，划分点需要记下来

**改进方法是** 锚点随机选择，不再只用最后一个数。

```C++
#include <random>
void quickSort(vector<int>& nums,int L,int R){
    if(L>=R){
        return;
    }
    ///产生随机数
    std::mt19937 rng;
    rng.seed(random_device()());
    std::uniform_int_distribution<std::mt19937::result_type> dist(L,R);
    swap(nums,dist(rng),R);

    vector<int> board;
    board=partition(nums,L,R,nums[R]);
    quickSort(nums,L,board[0]);
    quickSort(nums,board[1],R);
}
```

打乱数据结构的两种常用方法：

1. 随机打乱
2. 哈希函数

快排使用较多的原因是 代码简洁，常数项少。归并排序要辅助数组，排好放进辅助数组后还要再赋值回去，相当于遍历两次。

工程上不使用递归函数，会改为迭代形式。

## 堆排序

**时间复杂度：** O(n*lgn)     **额外空间复杂度：** O(1)

**堆**： 完全二叉树，一般用数组表示

**大根堆**： 任何一棵子树的最大值都是其头部

**小根堆**： 任何一棵子树的最小值都是其头部

### 数组变成大根堆

以数组 2 1 3 6 0 4 为例，依次添加新节点，大值与父节点交换。

建立一个大根堆的时间复杂度 log1+log2+log3+……+log(N-1) 收敛于 N   O(N)

### 吐出数的流找中位数

用一个 大根堆 和一个 小根堆实现

### 堆排序

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

///向大根堆中添加数据
void heapInsert(vector<int>& nums,int index){
    while(nums[index]>nums[(index-1)/2]){
        swap(nums[index],nums[(index-1)/2]);
        index = (index-1)/2;
    }
}

///本来是大根堆，有一个值发生了变化，从这个值开始和子节点交换
void heapify(vector<int>& nums,int index,int heapSize){
    int left = index*2 + 1;
    while(left < heapSize){
        ///左右孩子的最大值
        int largest = left+1<heapSize && nums[left+1]>nums[left]? (left+1):left;
        ///左右孩子与节点的最大值
        largest = nums[largest]>nums[index] ? largest:index;
        if(largest == index){
            break;
        }
        swap(nums[largest],nums[index]);
        index = largest;
        left = index*2 +1;
    }
}

void heapSort(vector<int>& nums){
    if(nums.size()<2){
        return;
    }
    for(int i=0;i<nums.size();++i){
        heapInsert(nums,i);
    }
    int heapSize = nums.size();
    swap(nums[0],nums[--heapSize]);
    while(heapSize>0){
        heapify(nums,0,heapSize);
        swap(nums[0],nums[--heapSize]);
    }
}

int main()
{
    vector<int> nums{3,2,4,5,2,6,7,1};
    heapSort(nums);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

# 第三课

## 排序的稳定性

相同值在排序前后的次序是不是一致

**稳定排序**：冒泡排序稳定，往上冒的过程中，遇到相同值不交换；

​                    插入排序稳定，往前插的过程中，遇到相同值停止；

​                    选择排序不稳定，5 5 5 5 5 5 4 0 1，第一次找到最小的0与第一个5交换，破坏了稳定性；

​                    归并排序稳定，在左右合并时，如果相等先拷贝左侧数据；

​					快速排序不稳定，两个相同的比锚点大的数，第一个先会放到more区域，第二个会放到第一个前面；

​                    堆排序也不稳定，因为它是跳着换的，4 4 4 5 5，建大根堆时，第二个 4 会和第一个 5 交换。

## 工程中的综合排序算法

如果是一个很长的数组，工程上会先进行判断，数组中是基础类型还是自定义的类型。如果是基础类型，会用快排，如果是自定义的类型，会用归并排序。这里是因为稳定性的关系，基础类型没有先后，自定义类型可能有先后。

如果数组很短（<60），会用插入排序。因为数组短时，O(n^2)的劣势体现不出来，插排的常数项很低，会很快。

如果是大数组，在进行递归归并时，数组长度小于60，直接插排。

## 自定义排序算法

## 桶排序、计数排序、基数排序

1. 这三种排序方法不是基于比较的排序。与被排序的样本的实际数据状况有很大关系，所以实际中并不常使用。
2. 时间复杂度O(n)，额外空间复杂度O(n)
3. 稳定的排序

举个例子，为什么是不基于比较的排序。我有一个数组nums，已知数据范围是 0~60，进行排序，就可以利用一个 长度为61（标号为0-60）的数组，遍历 nums，在对应标号处计数，遍历一次就可以知道 nums中 各个数据的 个数。这个排序称为 **计数排序**，是 **桶排序** 的一种。

### 给定数组，求如果排序后相邻两数的最大差值，要求时间复杂度 O(n)

利用了桶的思想，但不进行桶排序。N 个数，准备 N+1 个桶。第一次遍历，找到最小值和最大值，最小值放 1 号桶，最大值放 N 号桶，最小值到最大值等分为 N+1 份，其他数放入对应的桶。肯定会有空桶，最大差值一定跨桶。

具体步骤：遍历数组，只记录每个桶的最大值和最小值。

```c++
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
using namespace std;

int bucket(int num,int size,int Min,int Max){
    return (int)((num-Min)*size/(Max-Min));
}

int maxGap(vector<int>& nums){
    if(nums.size()<2){
        return 0;
    }

    int size = nums.size();
    int Min = INT_MAX;
    int Max = INT_MIN;

    for(int i:nums){
        Min = min(Min,i);
        Max = max(Max,i);
    }

    if(Min==Max){
        return 0;
    }

    vector<bool> hasNum(size+1,false);
    vector<int> maxs(size+1,0);
    vector<int> mins(size+1,0);

    int bid = 0;
    for(int i:nums){
        bid = bucket(i,size,Min,Max);
        mins[bid] = hasNum[bid]? min(i,mins[bid]):i;
        maxs[bid] = hasNum[bid]? max(i,maxs[bid]):i;
        hasNum[bid] = true;
    }

    int res = 0;
    int lastMax = maxs[0];

    for(int i=1;i<=size;++i){
        if(hasNum[i]){
            res = max(res,mins[i]-lastMax);
            lastMax = maxs[i];
        }
    }
    return res;
}

int main()
{
    vector<int> nums{1,4,2,6,9,5};
    cout<<maxGap(nums)<<endl;
    return 0;
}
```

## 数组实现固定大小的队列和栈

**数组实现栈**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayStack{
public:
    ArrayStack(int initSize){
        if(initSize<0){
            throw "The init size is less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;
    }

    ~ArrayStack(){
        delete arr;
    }

    void push(int obj){
        if(size==arr->size()){
            throw "The stack is full";
        }
        arr->at(size++) = obj;
    }

    int pop(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(--size);
    }

    int top(){
        if(size==0){
            throw "The stack is empty";
        }
        return arr->at(size-1);
    }
private:
    vector<int>* arr;
    int size;
};


int main(){
    ArrayStack as(3);
    as.push(1);
    cout<<as.top()<<endl;
    as.pop();
    cout<<as.top()<<endl;
    return 0;
}
```

**数组实现队列**

```c++
#include <iostream>
#include <vector>
using namespace std;

class ArrayQueue{
public:
    ArrayQueue(int initSize){
        if(initSize<0){
            throw "The init size less than 0";
        }
        arr = new vector<int>(initSize);
        size = 0;   ///记录队列中的元素数量
        head = 0;  ///head指向第一个数据的位置
        tail = 0;   ///tail指向可以放数据的位置
    }

    ~ArrayQueue(){
        delete arr;
    }

    void push(int obj){
        if(size == arr->size()){
            throw "The queue is full";
        }
        arr->at(tail) = obj;
        size++;
        tail = tail==arr->size()-1 ? 0:++tail;
    }

    void pop(){
        if(size == 0){
             throw "The queue is empty";
        }
        head = head==arr->size()-1? 0:++head;
        size--;
    }

    int front(){
        if(size == 0){
             throw "The queue is empty";
        }
        return arr->at(head);
    }

private:
    vector<int>* arr;
    int head;
    int tail;
    int size;
};

int main()
{
    ArrayQueue aq(2);
    aq.push(1);
    cout<<aq.front()<<endl;
    aq.push(2);
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    aq.pop();
    cout<<aq.front()<<endl;
    return 0;
}
```

## O(1)操作返回最小值的栈

**LeetCode 剑指offer30 包含min函数的栈**

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
using namespace std;

class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        _stack.push(x);
        if(minSta.empty()){
            minSta.push(x);
        }else{
            minSta.push(::min(x,minSta.top())); ///min命名冲突，使用域作用符调用库函数min
        } 
    }
    
    void pop() {
        _stack.pop();
        minSta.pop();
    }
    
    int top() {
        return _stack.top();
    }
    
    int min() {
        return minSta.top();
    }
private:
    stack<int> _stack;
    stack<int> minSta;
};
```

## 仅用队列结构实现栈

两个队列来回倒，保持一个队列始终为空

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class MyStack {
public:
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        if(q2.empty()){
            q1.push(x);
        }else{
            q2.push(x);
        }
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q2.pop();
            return tmp;
        }
    }

    /** Get the top element. */
    int top() {
        if(empty()){
            throw "The queue is empty";
        }
        if(!q1.empty()){
            while(q1.size()>1){
                q2.push(q1.front());
                q1.pop();
            }
            int tmp = q1.front();
            q2.push(q1.front());
            q1.pop();
            return tmp;
        }else{
            while(q2.size()>1){
                q1.push(q2.front());
                q2.pop();
            }
            int tmp = q2.front();
            q1.push(q2.front());
            q2.pop();
            return tmp;
        }
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty()&&q2.empty();
    }
private:
    queue<int> q1;
    queue<int> q2;
};
```

## 仅用栈结构实现队列

往栈1 push，从栈2 pop。与上一题的区别是，两个队列来回倒顺序不变，两个栈来回倒顺序会反过来。

栈2 空了，才能从栈1 往栈 2 拿。

```c++
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }

    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            int tmp = s2.top();
            s2.pop();
            return tmp;
        }
    }

    /** Get the front element. */
    int peek() {
        if(empty()){
            throw "Tne queue is empty";
        }
        if(!s2.empty()){
            return s2.top();
        }else{
            while(s1.size()){
                s2.push(s1.top());
                s1.pop();
            }
            return s2.top();
        }
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty()&&s2.empty();
    }
private:
    stack<int> s1;
    stack<int> s2;
};
```

# 第四课

## 猫狗队列

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/4.png)

## 剑指Offer 29 顺时针打印矩阵 LeetCode

**做法一：**自己想的，因为遍历很有规律，往右走 -> 往下走 -> 往左走 -> 往上走，再往右走 -> ……，所以用一个类似状态机的东西，四个函数依次调用。往右走完更改上边界，往下走完更改右边界，往左走完更改下边界，往上走完更改左边界。

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <limits.h>
#include <algorithm>
#include <queue>
using namespace std;

class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


int main()
{
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    Solution s;
    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}
```

**做法二：**算法课讲的，以一个圈为单位遍历，给定圈的左上点和右下点，遍历一圈。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2,vector<int>& res){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        ///只有一行，只需要往右走
        if(x1==x2){
            for(int i=y1;i<=y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
        }else if(y1==y2){
            for(int i=x1;i<=x2;++i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }else{
            ///向右走
            for(int i=y1;i<y2;++i){
                //cout<<matrix[x1][i]<<" ";
                res.push_back(matrix[x1][i]);
            }
            ///向下走
            for(int i=x1;i<x2;++i){
                //cout<<matrix[i][y2]<<" ";
                res.push_back(matrix[i][y2]);
            }
            ///向左走
            for(int i=y2;i>y1;--i){
                //cout<<matrix[x2][i]<<" ";
                res.push_back(matrix[x2][i]);
            }
            ///向上走
            for(int i=x2;i>x1;--i){
                //cout<<matrix[i][y1]<<" ";
                res.push_back(matrix[i][y1]);
            }
        }
    }

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }

        vector<int> res;

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;
        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1,y1,x2,y2,res);
             ++x1;
             ++y1;
             --x2;
             --y2;
        }
        return res;
    }
};

int main(){
    Solution s;
    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

    vector<int> res;
    res = s.spiralOrder(matrix);

    for(int i:res){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```



## LeetCode 旋转矩阵

**做法一：**利用上题做法一

矩阵顺时针旋转90度的思路利用上题顺时针遍历的做法。

先从 （0，0）点数字顺时针遍历，再从 第一行最后一个点 顺时针遍历，把第一次顺时针遍历的结果依次赋值给第二次。

```c++
///顺时针遍历矩阵
class Solution2 {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[3]++;
        down(matrix,x+1,board[0],board);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[0]--;
        left(matrix,board[1],y-1,board);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            res.push_back(matrix[x][i]);
        }
        board[1]--;
        up(matrix,x-1,board[2],board);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            res.push_back(matrix[i][y]);
        }
        board[2]++;
        right(matrix,board[3],y+1,board);
    }


    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return vector<int>();
        }
        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向右走
        right(matrix,0,0,board);

        return res;
    }
private:
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> res;
};


////给一个矩阵、一个起点和一个数组，从起点开始顺时针把数组的数组赋值给矩阵
class Solution {
public:
    ///判断输入点是否有效
    bool isAvailable(int x,int y,vector<int>& board){
        return x>=board[3]&&x<=board[1]&&y>=board[2]&&y<=board[0];
    }

    ///子函数1：输入起点，一直往右走到右边界,走完之后上边界加1
    void right(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i<=board[0];++i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[3]++;
        down(matrix,x+1,board[0],board,index);
    }

    ///子函数2：输入起点，一直往下走到下边界,走完之后右边界减1
    void down(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i<=board[1];++i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y] = nums[index++];
        }
        board[0]--;
        left(matrix,board[1],y-1,board,index);
    }

    ///子函数3：输入起点，一直往左走到左边界,走完之后下边界减1
    void left(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=y;i>=board[2];--i){
            //cout<<matrix[x][i]<<" ";
            matrix[x][i]= nums[index++];
        }
        board[1]--;
        up(matrix,x-1,board[2],board,index);
    }

    ///子函数4：输入起点，一直往上走到上边界,走完之后上边界加1
    void up(vector<vector<int>>& matrix,int x,int y,vector<int>& board,int& index){
        if(!isAvailable(x,y,board)){
            return;
        }

        for(int i=x;i>=board[3];--i){
            //cout<<matrix[i][y]<<" ";
            matrix[i][y]= nums[index++];
        }
        board[2]++;
        right(matrix,board[3],y+1,board,index);
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return;
        }

        nums = s.spiralOrder(matrix);

        ///初始化边界
        board[0]=matrix[0].size()-1;
        board[1]=matrix.size()-1;

        ///最开始向下走
        int index =0;
        down(matrix,0,board[0],board,index);
    }
private:
    Solution2 s;
    vector<int> board{0,0,0,0};  ///四个边界，右0、下1、左2、上3
    vector<int> nums;
};
```

**做法二：**与上题做法二思路类似，一圈一圈处理。

```c++
class Solution {
public:
    ///输入左上点和右下点，打印一圈
    void printBoard(vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
        ///输入有效性判断
        if(x1>x2||y1>y2){
            return;
        }

        for(int i=0;i<x2-x1;++i){
            int tmp = matrix[x1][y1+i];
            matrix[x1][y1+i]=matrix[x2-i][y1];
            matrix[x2-i][y1]=matrix[x2][y2-i];
            matrix[x2][y2-i]=matrix[x1+i][y2];
            matrix[x1+i][y2]= tmp;
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        if(matrix.size()<2){
            return;
        }

        int x1 = 0;
        int y1 = 0;
        int x2 = matrix.size()-1;
        int y2 = matrix[0].size()-1;

        while(x1<=x2&&y1<=y2){
             printBoard(matrix,x1++,y1++,x2--,y2--);
        }
    }
};
```

## “之”字形打印矩阵

**做法一：**自己想的，处理思路是 横着走、竖着走二选一，左下和右上二选一，一般情况是，横走一格、左下到头、竖走一格、右上到头；轮到横走时，先看能不能横走，不能横走就竖走；轮到竖走时，看能不能竖走，不能竖走就横走。

```c++
#include <iostream>
#include <vector>

using namespace std;

void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x=0, y=0;
    cout<<matrix[0][0]<<" ";

    int rows = matrix.size();
    int cols = matrix[0].size();
    ///flag0记录上一次是横走还是竖走, true 为竖走，因为第一次要横走
    bool flag0 = true;
    ///flag1记录上一次是左下还是右上，true 为右上
    bool flag1 = true;

    while(x<rows-1||y<cols-1){
        ///先横着走、竖着走选一个
        if(flag0){
            if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }else if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }
            flag0 = false;
        }else{
            if(x+1<rows){
                cout<<matrix[++x][y]<<" ";
            }else if(y+1<cols){
                cout<<matrix[x][++y]<<" ";
            }
            flag0 = true;
        }
        ///再左下走和右上走选一个
        if(flag1){
            while(x+1<rows&&y-1>=0){
                cout<<matrix[++x][--y]<<" ";
            }
            flag1 = false;
        }else{
            while(x-1>=0&&y+1<cols){
                cout<<matrix[--x][++y]<<" ";
            }
            flag1 = true;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

**做法二：**视频课里讲的

​     ![之字形](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/1.png)

如图，A往右走，B往下走，A、B连线就是一条访问路径，A不能往右走时往下走，B不能往下走时往右走。

bool型变量标识每次是从A到B输出还是从B到A输出。

```c++
#include <iostream>
#include <vector>

using namespace std;

///输入两点，打印斜对角，根据bool值,true从A->B，flase从B->A
void printAB(bool& flag,vector<vector<int>>& matrix,int x1,int y1,int x2,int y2){
    if(flag){
        for(int i=x1;i<=x2;++i){
            cout<<matrix[i][y1--]<<" ";
        }
    }else{
        for(int i=x2;i>=x1;--i){
            cout<<matrix[i][y2++]<<" ";
        }
    }
    flag=!flag;
}


void ZprintMatrix(vector<vector<int>>& matrix){
    if(matrix.empty()||matrix.size()*matrix[0].size()<2){
        return;
    }
    ///起点
    int x1=0, y1=0;
    int x2=0, y2=0;
    bool flag = false;

    int rows = matrix.size();
    int cols = matrix[0].size();

    while(x1<rows||y1<cols){
        printAB(flag,matrix,x1,y1,x2,y2);
        if(y1<cols-1){
            y1++;
        }else{
            x1++;
        }

        if(x2<rows-1){
            x2++;
        }else{
            y2++;
        }
    }
}


int main(){

    vector<vector<int>> matrix{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
    ZprintMatrix(matrix);

    return 0;
}
```

## 在行和列都排好序的矩阵中找是否存在数k

N*M的矩阵，时间复杂度为 O(N+M)，空间复杂度为 O(1)

```c++
#include <iostream>
#include <vector>

using namespace std;

bool ifExist(vector<vector<int>>& matrix,int k){
    int x1 = 0;
    int y1 = matrix[0].size()-1;
    
    while(x1<matrix.size()&&y1<matrix[0].size()){
        if(k == matrix[x1][y1]){
            return true;
        }else if(k < matrix[x1][y1]){
            --y1;
        }else{
            ++x1;
        }
    }

    return false;
}


int main(){
    vector<vector<int>> matrix{{0,1,2,5},{2,3,4,7},{4,4,4,8},{5,7,7,9}};
    cout<<ifExist(matrix,7)<<endl;
    cout<<ifExist(matrix,6)<<endl;
    return 0;
}
```

## 打印两个有序链表的公共部分

和merge的过程差不多，两个指针比对往后走

## LeetCode 回文链表

链表问题一般在空间复杂度上下功夫

**普通做法：**第一遍遍历链表，依次进栈；第二次遍历链表，依次与栈顶元素比对。 时间复杂度O(n)，额外空间复杂度O(n)。

或者先用快慢指针找到中点，把后半段入栈，再比较。 

**进阶：**时间复杂度O(n)，空间复杂度O(1)。

先用快慢指针找到中点，后半段翻转，分别从两头比较，比完再翻转回去。

![回文判断](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/2.jpg)

如图，编程确保奇数结点时，慢指针指向中间，偶数结点时，慢指针指向前半最哦胡一个结点。

从两头往中间比对，一端到达 null 结束

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ///输入有效性判断
        if(head == nullptr || head->next == nullptr){
            return true;
        }
        ///定义快慢指针
        ListNode* slow = head;
        ListNode* fast = head;

        ///经过while的处理会发生两种情况
        ///奇数个结点：slow指向正中间，fast指向尾结点
        ///偶数个结点：slow指向前边部分最后一个结点，fast指向尾结点前一个结点
        while(fast!=nullptr&&fast->next != nullptr&&fast->next->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        ///如果是偶数个结点的情况fast后移一位，指向尾结点
        if(fast!=nullptr&&fast->next!=nullptr){
            fast = fast->next;
        }


        ///从slow结点开始翻转链表
        ListNode* pre = slow;
        ListNode* last = slow->next;
        slow->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }

        ///从两头依次比对
        pre = head;
        last = fast;
        bool res = true;
        while(pre != nullptr&&last != nullptr){
            if(pre->val != last->val){
                res = false;
                break;
            }
            pre = pre->next;
            last = last->next;
        }

        ///再把链表翻转回来
        pre = fast;
        if(pre!=nullptr){
            last = pre->next;
        }

        pre->next = nullptr;
        while(last!=nullptr){
            ListNode* temp = last->next;
            last->next = pre;
            pre = last;
            last = temp;
        }
        return res;
    }
};

int main()
{
    ListNode node1(1);
    ListNode node2(0);
    ListNode node3(3);
    ListNode node4(4);
    ListNode node5(0);
    ListNode node6(1);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;

    Solution s;
    cout<<s.isPalindrome(&node1)<<endl;

    ListNode* head = &node1;
    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## 将单向链表按某值划分为左边小、中间相等、右边大的形式

要求：保证稳定性，时间复杂度O(n)，额外空间复杂度O(1)

可以拿出来放进数组里，用快排中的 partition 类似，但partition 不具有稳定性。

**方法：**分成三个链表，小于的，等于的，大于的，再合起来

```c++
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* listPartition(ListNode* head,int num){
    if(head==nullptr){
        return head;
    }

    ListNode* sH = nullptr; //小于链表的头
    ListNode* sT = nullptr; //小于链表的尾
    ListNode* eH = nullptr; //等于链表的头
    ListNode* eT = nullptr; //等于链表的尾
    ListNode* bH = nullptr; //大于链表的头
    ListNode* bT = nullptr; //大于链表的尾

    ///注意取出一个结点时，先打断他和后继结点的链接
    ListNode* temp = nullptr; //用于遍历
    while(head!=nullptr){
        temp = head ->next;
        head->next = nullptr;

        if(head->val<num){
            if(sH == nullptr){
                sH = head;
                sT = head;
            }else{
                sT->next = head;
                sT = sT->next;
            }
        }else if(head->val==num){
            if(eH == nullptr){
                eH = head;
                eT = head;
            }else{
                eT->next = head;
                eT = eT->next;
            }
        }else{
            if(bH == nullptr){
                bH = head;
                bT = head;
            }else{
                bT->next = head;
                bT = bT->next;
            }
        }
        head=temp;
    }

    if(sT!=nullptr){
        sT->next = eH;
        eT = eT ==nullptr? sT:eT;
    }

    if(eT!=nullptr){
        eT->next =bH;
    }
    return sH!=nullptr? sH:(eH!=nullptr?eH:bH);
}

int main()
{
    ListNode node1(9);
    ListNode node2(4);
    ListNode node3(5);
    ListNode node4(8);
    ListNode node5(2);
    ListNode node6(5);


    node1.next= &node2;
    node2.next= &node3;
    node3.next= &node4;
    node4.next= &node5;
    node5.next= &node6;


    ListNode* head =listPartition(&node1,5);

    while(head!=nullptr){
        cout<<head->val<<" ";
        head=head->next;
    }
    cout<<endl;

    return 0;
}
```

## LeetCode138 复制带随机指针的链表

下面的两个方法思路相同

**使用哈希表的方法**

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};


class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*> map;
        Node* cur = head;

        ///先遍历结点，记录在哈希表中
        while(cur!=nullptr){
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        
        cur = head;
        while(cur != nullptr){
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        
        return map[head];
    }
};
```

**不使用哈希表的方法**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr){
            return head;
        }
        Node* cur = head;
        Node* next = nullptr;
        
        ///复制一份结点出来接在当前结点后面
        while(cur != nullptr){
            next = cur->next;
            cur->next = new Node(cur->val);
            cur->next->next = next;
            cur = next;
        }
        
        ///第二次遍历，构建random链接
        cur = head;
        Node* curCopy = nullptr;
        while(cur!=nullptr){
            curCopy = cur->next;
            curCopy->random = cur->random!=nullptr? cur->random->next:nullptr;
            cur = cur->next->next;
        }
        
        ///恢复链表
        Node* res = head->next;
        
        cur = head;
        while(cur!=nullptr){
            curCopy = cur->next;
            cur->next = cur->next->next;
            curCopy->next = cur->next == nullptr? nullptr:cur->next->next;
            cur = cur->next;
        }
        return res;
    }
};
```

 ## LeetCode 链表相交

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/3.png)

### 判断单链表是否有环

**方法一：使用哈希表**

遍历结点，存入哈希表，判断之前有没有出现过该结点。

**方法二：快慢指针**

如果有环，当快指针比慢指针多走一个环的长度时，二者相遇；

此时，快指针回到头结点，快慢指针每次都走一个，会在入环结点相遇。总长减环长等于总长减环长。

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ///返回链表入环点
    ListNode *detectCycle(ListNode *head) {
        if(head==nullptr||head->next==nullptr||head->next->next==nullptr){
            return nullptr;
        }
        ListNode* slow=head->next;
        ListNode* fast=head->next->next;

        while(slow!=fast){
            if(fast->next==nullptr||fast->next->next==nullptr){
                return nullptr;
            }
            fast = fast->next->next;
            slow = slow->next;
        }

        fast = head;
        while(fast!=slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }

    ///如果都无环返回相交点
    ListNode* noLoop(ListNode* head1,ListNode* head2){
        if(head1==nullptr||head2==nullptr){
            return nullptr;
        }
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        int n = 0;
        while(cur1->next!=nullptr){
            n++;
            cur1 = cur1->next;
        }
        while(cur2->next!=nullptr){
            n--;
            cur2 = cur2->next;
        }
        if(cur1!=cur2){
            return nullptr;
        }
        cur1 = head1;
        cur2 = head2;
        while(n>0){
            cur1 = cur1->next;
            n--;
        }
        while(n<0){
            cur2 = cur2->next;
            n++;
        }
        while(cur1!=cur2){
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        return cur1;
    }
    ///如果都有环返回相交点
    ListNode* bothLoop(ListNode* head1,ListNode* head2,ListNode* loop1,ListNode* loop2){
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;
        ///如果在环前相交
        if(loop1 == loop2){
            int n=0;
            while(cur1!=loop1){
                n++;
                cur1 = cur1->next;
            }
            
            while(cur2!=loop2){
                n--;
                cur2 = cur2->next;
            }
            
            cur1 = head1;
            cur2 = head2;
            while(n>0){
                cur1 = cur1->next;
                n--;
            }
            while(n<0){
                cur2 = cur2->next;
                n++;
            }
            while(cur1!=cur2){
                cur1 = cur1->next;
                cur2 = cur2->next;
            }
            return cur1;
        }else{
            cur1 = loop1->next;
            while(cur1!=loop1){
                if(cur1 == loop2){
                    return loop1;
                }
                cur1=cur1->next;
            }
            return nullptr;
        }
    }

    ListNode* getIntersectionNode(ListNode* head1,ListNode* head2){
        if(head1 == nullptr||head2 == nullptr){
            return nullptr;
        }

        ListNode* loop1 = detectCycle(head1);
        ListNode* loop2 = detectCycle(head2);

        if(loop1 == nullptr&&loop2 == nullptr){
            return noLoop(head1,head2);
        }
        if(loop1 !=nullptr&&head2!=nullptr){
            return bothLoop(head1,head2,loop1,loop2);
        }
        return nullptr;
    }
};

```

# 第五课

## 二叉树的遍历

### 递归

三种递归方式的代码除了打印的位置不同，其他都相同。

本质上他们访问结点的顺序相同，每个结点会访问3次，分别对应三种顺序的遍历。

先序：先打印根节点，再打印左子树，再打印右子树。

#### 先序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    void preorder(TreeNode* root,vector<int>& v){
        if(root==nullptr){
            return;
        }
        v.push_back(root->val);
        preorder(root->left,v);
        preorder(root->right,v);
    }
    
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        preorder(root,res);
        return res;
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void inorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        inorder(root->left,v);
        v.push_back(root->val);
        inorder(root->right,v);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        inorder(root,res);
        return res;
    }
};
```

#### 后序

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void postorder(TreeNode* root,vector<int>& v){
        if(root == nullptr){
            return;
        }
        postorder(root->left,v);
        postorder(root->right,v);
        v.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        postorder(root,res);
        return res;
    }
};
```

### 迭代

#### 先序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            res.push_back(root->val);
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
        }
        return res;    
    }
};
```

#### 中序

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr){
            return vector<int>();
        }
        vector<int> res;
        
        stack<TreeNode*> treeStack;
        
        while(!treeStack.empty()||root!=nullptr){
            if(root!=nullptr){
                treeStack.push(root);
                root = root->left;
            }else{
                root = treeStack.top();
                treeStack.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }    
        return res;
    }
};
```

#### 后序

用两个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        stack<int> help;
        treeStack.push(root);
        
        while(!treeStack.empty()){
            root = treeStack.top();
            treeStack.pop();
            help.push(root->val);
            if(root->left!=nullptr){
                treeStack.push(root->left);
            }
            if(root->right!=nullptr){
                treeStack.push(root->right);
            }
        }
        
        while(!help.empty()){
            res.push_back(help.top());
            help.pop();
        }
        
        return res;
    }
};
```

用一个栈实现

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr){
            return vector<int>();
        }
        vector<int> res;
        stack<TreeNode*> treeStack;
        treeStack.push(root);
        
        TreeNode* c= nullptr;
        
        while(!treeStack.empty()){
            c = treeStack.top();
            if(c->left!=nullptr&&root!=c->left&&root!=c->right){
                treeStack.push(c->left);
            }else if(c->right!=nullptr&&root!=c->right){
                treeStack.push(c->right);
            }else{
                res.push_back(treeStack.top()->val);
                treeStack.pop();
                root = c;
            }
        }

        return res;
    }
};
```

## 二叉树中的后继结点与前驱结点

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/5.png)

如果结点有右子树，这个结点就是一个根节点，左->根->右，后继结点就是右子树的最左结点

如果没有右子树，那它的角色就是某棵左树的最后一个结点，他要找这棵左树的根，找是别人左孩子的祖先结点。

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *parent;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* getLeftMost(TreeNode* node){
    if(node == nullptr){
        return nullptr;
    }
    while(node->left!=nullptr){
        node=node->left;
    }
    return node;
}

TreeNode* getSuccessorNode(TreeNode* node){
    if(node == nullptr){
        return node;
    }
    if(node->right != nullptr){
        return getLeftMost(node->right);
    }else{
        TreeNode* parent = node->parent;
        while(parent!=nullptr && parent->left != node){
            node = parent;
            parent = node->parent;
        }
        return parent;
    }
}
```

## LeetCode297 二叉树序列化与反序列化

先序遍历的方式

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == nullptr){
            return "#!";
        }
        string res = to_string(root->val) + "!";
        res += serialize(root->left);
        res += serialize(root->right);
        return res;
    }

    TreeNode* reconPreOrder(queue<string>& queue){
        string value = queue.front();
        queue.pop();
        if(value == "#"){
            return nullptr;
        }
        TreeNode* head = new TreeNode(stoi(value));
        head->left = reconPreOrder(queue);
        head->right = reconPreOrder(queue);
        return head;
    }
    
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        regex re("!");
        vector<string> v(sregex_token_iterator(data.begin(),data.end(),re,-1),sregex_token_iterator());
        
        queue<string> queue;
        for(const string& s:v){
            queue.push(s);
        }
        
        return reconPreOrder(queue);
    }
};

```

## LeetCode110 平衡二叉树

**第一版：**

返回每个结点的高度及是否平衡

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        pair<int,bool> depR = depth(root->right);

        if(abs(depL.first-depR.first)<=1&&depL.second == true&&depR.second == true){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

**第二版：**

不必知道最终树的高度，如果判断出来左子树或右子树不平衡，直接返回

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:

    pair<int,bool> depth(TreeNode* root){
        if(root == nullptr){
            return pair<int,bool>(0,true);
        }
        pair<int,bool> depL = depth(root->left);
        
        if(depL.second == false){
            return pair<int,bool>(0,false);
        }
        
        pair<int,bool> depR = depth(root->right);
        
        if(depR.second == false){
            return pair<int,bool>(0,false);
        }

        if(abs(depL.first-depR.first)<=1){
            return pair<int,bool>(max(depL.first,depR.first)+1,true);
        }
        return pair<int,bool>(max(depL.first,depR.first)+1,false);
    }

    bool isBalanced(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        return depth(root).second;
    }
};
```

## LeetCode 98 搜索二叉树

**使用左右子树依次判断再返回的方式**

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    ///返回是否为二叉搜索树，最小值，最大值
    pair<bool,vector<int>> isValid(TreeNode* root){
        if(root == nullptr){
            return pair<bool,vector<int>>(true,{INT_MAX,INT_MIN});
        }
        pair<bool,vector<int>> left = isValid(root->left);
        if(left.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        pair<bool,vector<int>> right = isValid(root->right);
        if(right.first == false){
            return pair<bool,vector<int>>(false,{0,0});
        }
        if((root->left!=nullptr&&left.second[1]>=root->val)||(root->right!=nullptr&&right.second[0]<=root->val)){
            return pair<bool,vector<int>>(false,{0,0});
        }

        return pair<bool,vector<int>>(true,{min(left.second[0],root->val),max(right.second[1],root->val)});
    }

    bool isValidBST(TreeNode* root) {
        return isValid(root).first;
    }
};
```

**使用判断中序遍历是否升序的方式**

待完成

## LeetCode 958 二叉树的完全性验证

```c++
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        if(root == nullptr){
            return true;
        }
        queue<TreeNode*> treeQueue;
        ///flag，标记，之后只能是叶节点
        bool leaf = false;
        TreeNode* l = nullptr;
        TreeNode* r = nullptr;
        treeQueue.push(root);
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            l = root->left;
            r = root->right;
            if((leaf&&(l!=nullptr||r!=nullptr))||(l==nullptr&&r!=nullptr)){
                return false;
            }
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
                leaf = true;
            }
        }
        return true;
    }
};
```

## LeetCode 222 完全二叉树的节点个数

**自己想的：**与判断完全二叉树思路相同，知道之后都是叶子节点以后就不用判断了。

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x,TreeNode* l,TreeNode* r):val(x),left(l),right(r){}
};

class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr){
            return 0;
        }
        queue<TreeNode*> treeQueue;
        treeQueue.push(root);
        
        int res = 0;
        
        while(!treeQueue.empty()){
            root = treeQueue.front();
            treeQueue.pop();
            res++;
            TreeNode* l = root->left;
            TreeNode* r = root->right;
            if(l!=nullptr){
                treeQueue.push(l);
            }
            if(r!=nullptr){
                treeQueue.push(r);
            }else{
               res += treeQueue.size();
               break;
            }
        }
        return res;
    }
};
```

# 第六课

## 哈希函数与哈希表

### 哈希函数

**性质**

1. 输入域无穷大
2. 输出域有穷尽
3. 输入参数一定，返回值也确定
4. 输入不一样，输出可能一样（哈希碰撞）
5. 离散型 -> 分布均匀

**其它性质**

1. 输入有规律，输出没规律，否则无法均匀

2. 输出的结果在S域上，用输出结果对 m 取模，结果会在 0~m-1上均匀分布

   如果需要很多个哈希函数，可以用一个哈希函数改出来，并且互相独立。

   改的方法是，假如某哈希函数会得到一个结果h，h为16字节数据，把h分为 **高8字节h1** 和**低8位字节h2**则可通过以下方式得到互相独立的哈希函数：

   h1 + h2

   h1 + 2*h2

   h1 + 3*h2

   ……

   其实，16字节的每个字节之间都是互相独立的。

### 哈希表

哈希表的经典结构，假如哈希表一上来给你分配17的内存空间，这时你向哈希表中存入 key1，通过哈希函数得到对应的哈希值，哈希值模 17 得到 0~16 的值，放入对应的位置，这样一直放，可能会出现冲突，冲突后就往后挂，形成类似链表的结构（java中是红黑树）。根据哈希表的性质，我们可以认为 0~16 每个位置之后挂的 节点基本是相当的。后面挂的越多，查找的效率就越低，所以当挂到一定数量时，需要扩大哈希表。假如我扩到104，这时候我需要把哈希表中所有的数都重新求一遍哈希值，对104取模。扩容的代价，因为是成倍扩容，所以是 logN的复杂度，不仅如此，还可以离线扩容，我还往老结构中存，在线下把数据转移（JVM的托管）。有很多加速技巧，所以说 哈希表增删改查为 O(1)。

### 大数据问题

有1000T的字符串找相同字符串

1. 有多台机器处理吗？如果有1000台，可以对字符串求哈希函数再对1000取模，把字符串分散到1000台机器上。因为哈希函数有相同的输入一定有相同的输出，不同的输入均匀分布的特点。

### 设计RandomPoll结构

```c++
/*设计一种结构，在该结构中有如下三个功能：
 * 1.insert(key):将某个key加入到该结构
 * 2.delete(key):将原本在结构中的某个key移除
 * 3.getRandom():等概率随机返回结构中的任何一个key
 * 要求:insert、delete和getRandom方法的时间复杂度都是O(1) 
*/

/*设计思路:使用两个哈希表
 *1.insert(key):哈希表1存入 key + 编号(这是第几个插入的数，第一个为0，依次递增);
 *  哈希表2存入 编号 + key
 *2.getRandom():使用随机数函数在 0-最后一个编号 中产生随机数，利用哈希表2返回一个key
 *3.delete(key):在哈希表1和哈希表2中删除对应的key;删除后 0-最后一个编号中出现空缺，影响 getRandom(),
 *  把最后一个编号的 key 放到空缺的位置。
 */
```

### 布隆过滤器

```
/*有1000亿个url的黑名单,每个 url 64字节,给你一个 url,判断是否属于这个黑名单集合
*/

/*设计思路:
 *1.使用哈希表来做，可以准确的知道是否属于，但需要很大的空间，这么大的空间要做成哈希表放在内存中，代价很大
 *2.或者用哈希函数分流，分到多台机器上，代价也很大
 *3.布隆过滤器。布隆过滤器是一种集合，判断某个元素是否属于这个集合。布隆过滤器有失误率，某个url应该不在黑名单中，但会返回true
 *4.布隆过滤器使用 bitmap,
 *5.如果我准备了一个 m 位的 bitmap，将url的字符串通过哈希函数求得一个哈希值，模m，将bitmap对应位置置1
 *6.准备k个互相独立的哈希函数，将url的字符串通过k个哈希函数，模m，得到k个位置，k个位置可能重复，将k个位置置1，
 *7.查询的时候我按相同的方法求出 k个位置，如果k个位置都黑，则认为在黑名单中。
 *8.bitmap要长一些，否则大量数据下每个位都会变黑。bitmap越长，失误率越低。bitmap大小 m = -(n*lnp)/(ln2)^2。
 *  n为样本量，p为预期失误率
 *9.哈希函数的个数 k = ln2*(m/n)
 *10.实际失误率p =(1-e^(-n*k/m))^k
 *11.以下代码是一个位操作的示例，在C++中，可以使用数据结构 bitset
 */

#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> arr(1000,0); //32000个bit位，每位都是0
    ///如果想让第 30000 bit位为1
    int index = 30000;
    int intIndex = index/32;
    int bitIndex = index%32;
    arr[intIndex] = (arr[intIndex]|(1<<bitIndex));
    return 0;
}
```

### 一致性哈希

假如我前端有几台机器，后端有3台机器 0 1 2，哈希函数可以较好地实现复杂均衡，使 0 1 2 三台机器的处理量相当。但当我增加机器时，增加到100台，需要将之前的数据重新计算，迁移过来，迁移代价较大。

一致性哈希是我求出的节点不再模3，而是将 2^64 次个数均分给3台机器，均分的方式是，给 3个节点每个节点 1000 个虚拟节点，虚拟节点负责的数据交给实际对应的机器处理。新加机器时，也给他分配 1000 个虚拟节点，虚拟节点数据的迁移对应到物理机器上。

# 第七课

## 并查集

并查集有两个作用：

1. 判断两个元素是否属于同一个集合。 isSameSet(A,B)
2. 合并两个元素所在的集合。union(A,B)

实现并查集可以用多种方式，例如 链表、哈希表等，但如何快速地实现并查集的两个功能是设计结构时需要考虑的问题。

经典的并查集结构是通过多叉树实现的，每个节点都有一个指针指向自己的父节点，每棵树的代表节点指向自己。

查询两个节点所在树的代表节点是否相同，判断是否属于同一集合。

将一个集合的代表节点的父节点指向另一个集合的代表节点，实现集合的合并。

**注：在这里我们可以看到并查集用的树结构不是普通的树，普通的树父节点指向孩子节点，从根往下分叉，并查集的结构孩子指向父，从叶子向上汇聚**
有两点要注意的：

1. 两个集合合并时，将数量少的集合挂在数量较多的集合上效率更高
2. 当查询完一个节点之后，将他直接挂在代表节点的下面，方便下一次的查询。

**使用哈希表实现并查集示例：**

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

///并查集中存放的节点类型，存放什么都可以
class Node{
public:
    bool operator !=(Node node){
    
    }
    bool operator ==(Node node){
        
    }
};

class UnionFindSet{
public:
    UnionFindSet(vector<Node>& nodes){
        makeSets(nodes);
    }

    Node findHead(Node node){
        Node father = fatherMap[node];
        if(father!=node){
            father = findHead(father);
        }
        fatherMap[node] = father;
        return father;
    }
    
    bool isSameSet(Node a,Node b){
        return findHead(a) == findHead(b);
    }
    
    void Union(Node a,Node b){
        Node aHead = findHead(a);
        Node bHead = findHead(b);
        if(aHead!=bHead){
            int aSetSize = sizeMap[aHead];
            int bSetSize = sizeMap[bHead];
            if(aSetSize <= bSetSize){
                fatherMap[aHead] = bHead;
                sizeMap[bHead] = aSetSize+bSetSize;
            }else{
                fatherMap[bHead] = aHead;
                sizeMap[aHead] = aSetSize+bSetSize;
            }
        }
    }
private:
    unordered_map<Node,Node> fatherMap;
    unordered_map<Node,int> sizeMap;

    void makeSets(vector<Node>& nodes){
        fatherMap.clear();
        sizeMap.clear();
        for(Node node:nodes){
            fatherMap.push(node,node);
            sizeMap.put(node,1);
        }
    }
};
```

### LeetCode 200 岛屿数量

岛屿数量的经典解法是使用递归来做，与种子填充思路相同

```c++
class Solution {
public:
    void infect(vector<vector<char>>& grid,int rows,int cols,int x,int y){
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]!='1'){
            return;
        }
        grid[x][y] = '2';
        infect(grid,rows,cols,x-1,y);
        infect(grid,rows,cols,x+1,y);
        infect(grid,rows,cols,x,y-1);
        infect(grid,rows,cols,x,y+1);        
    }

    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0||grid[0].size()==0){
            return 0;
        }
        int rows = grid.size();
        int cols = grid[0].size();
        int res=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(grid[i][j]=='1'){
                    infect(grid,rows,cols,i,j);
                    res++;
                }
            }
        }
        return res;
    }
};
```

如果矩阵非常大，需要拆分成很多小矩阵再合并起来，合并的时候使用并查集来合并。

## 前缀树

```c++
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct TrieNode{
    int path = 0; ///以该前缀开头的字符串个数
    int end = 0;  ///以该前缀结尾的字符串个数
    vector<TrieNode*> nexts;

    TrieNode(){
        nexts = vector<TrieNode*>(26,nullptr);
    }
};

class Trie{
public:
    Trie(){
        root = new TrieNode();
    }
    void insert(string word){
        if(word.empty()){
            return;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();i++){
            index = word[i] - 'a';
            if(node->nexts[index] == nullptr){
                node->nexts[index] = new TrieNode();
            }
            node = node->nexts[index];
            node->path++;
        }
        node->end++;
    }

    void mdelete(string word){
        if(search(word) == 0){
            return;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();++i){
            index = word[i] - 'a';
            if(--node->nexts[index]->path == 0){
                node->nexts[index] = nullptr;
                return;
            }
            node = node->nexts[index];
        }
        node->end--;
    }

    int search(string word){
        if(word.empty()){
            return 0;
        }
        TrieNode* node = root;
        int index = 0;
        for(int i=0;i<word.size();i++){
            index = word[i] - 'a';
            if(node->nexts[index] == nullptr){
                return 0;
            }
            node = node->nexts[index];
        }
        return node->end;
    }
private:
    TrieNode* root;
};


int main()
{
    string s1{"abc"};
    string s2{"abcd"};
    string s3{"bcd"};

    Trie trie;
    trie.insert(s1);
    trie.insert(s2);
    trie.insert(s3);

    cout<<"jzz"<<endl;

    cout<<trie.search(s1)<<" "<<trie.search(s2)<<" "<<trie.search(s3)<<endl;
    cout<<trie.search("ab")<<" "<<trie.search("abcde")<<" "<<trie.search(s3)<<endl;

    return 0;
}
```

# 第八课

## 贪心策略

贪心策略的证明很复杂，不要考虑

### LeetCode 179 最大数

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[](int a,int b){ return stol(to_string(a)+to_string(b))>stol(to_string(b)+to_string(a));});
        ///加这句判断是因为可能数组中都是0，只需要输出一个0
        if(nums[0]==0){
            return string{"0"};
        }

        stri ng res;
        for(int i:nums){
            res+=to_string(i);
        }
        return res;
    }
};
```

   题目的关键是找一个比较策略，比较器需要具备以下性质：

1. 传递性，如果 a.b小于等于b.a，b.c小于等于c.b，则 a.c小于等于c.a

2. 还要证明按这种方法排完的结果是最大的数，反证法，将按这种方法排好序的结果中任交换两个，结果都会变大。

### 分割数组的最小代价

哈夫曼编码问题，两个节点合起来的代价是两个节点的和，怎么代价最小

方法：使用小根堆，每次取出两个最小的合在一起，代价是它俩的和，再取最小的和这个数和。

证明比较麻烦

### LeetCode 502 IPO

方法：按花费把所有项目放小根堆，把所有比初始资金小的弹出来，按收益放进大根堆，从大根堆里弹出来一个做；做完之后资金增长，再从小根堆里弹出可以做的项目，放入大根堆，再大根堆中弹。

```c++
class Solution {
public:
    int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital) {
        ///小根堆，按花费排序
        auto cmp1 = [](pair<int,int> a,pair<int,int> b){
            return a.second>b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype (cmp1)> minCostQ(cmp1);
        ///大根堆，按利益排序
        auto cmp2 = [](pair<int,int>a,pair<int,int> b){
            return a.first<b.first;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype (cmp2)> maxProfitQ(cmp2);

        ///先把所有项目放入小根堆
        for(int i=0;i<Profits.size();i++){
            minCostQ.push(pair<int,int>(Profits[i],Capital[i]));
        }
        ///取出项目，取k次
        for(int i=0;i<k;i++){
            while(!minCostQ.empty()&&minCostQ.top().second<=W){
                maxProfitQ.push(minCostQ.top());
                minCostQ.pop();
            }
            if(maxProfitQ.empty()){
                return W;
            }
            W+=maxProfitQ.top().first;
            maxProfitQ.pop();
        }
        return W;
    }
};
```

### LeetCode 1353 最多可以参加的会议数目

### 最多可以参加的会议数目

和力扣那个题比一样

按照哪个项目早结束贪心

```c++
class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        sort(events.begin(),events.end(),[](vector<int>& a,vector<int>& b){
            return a[1]<b[1];
        });
        int res = 0;
        int end = 0;
        for(int i=0;i<events.size();i++){
            if(end<=events[i][0]){
                res++;
                end = events[i][1];
            }
        }
        return res;
    }
};
```

## 暴力递归与动态规划

**计算 n！**

```c++
long getFactorial1(int n){
    if(n==1){
        return 1;
    }
    return (long)n*getFactorial1(n-1);
}

long getFactorial2(int n){
    long res = 1;
    for(int i=1;i<=n;i++){
        res *= i;
    }
    return res;
}
```

**汉诺塔问题**

```c++
void process(int N,string from,string to,string help){
    if(N == 1){
        cout<<"Move 1 "<<from<<" to "<<to<<endl;
        return;
    }
    process(N-1,from,help,to);
    cout<<"Move "<<N<<" "<<from<<" to "<<to<<endl;
    process(N-1,help,to,from);
}

int main()
{
    int n=3;
    process(n,"A","B","C");
    return 0;
}
```

T(n) = T(n-1) + 1 + T(n-1);

等差数列

汉诺塔问题的步数是 2^n-1

### 打印一个字符串全部的子序列，包括空字符串

```c++
void process(string str,int n,string cur){
    if(n==str.size()){
        cout<<cur<<endl;
        return;
    }
    process(str,n+1,cur+str[n]);
    process(str,n+1,cur+" ");
}

int main()
{
    string str="abc";
    string cur=" ";
    process(str,0,cur);
    return 0;
}
```

### 母牛繁殖

母牛每年生一只母牛，新出生的母牛成长3年后也能每年生一只母牛，假设不会死，求N年后，母牛的数量。

f(n) = f(n-1) + f(n-3)

解释：今年的牛的数量等于 去年的牛的数量  + 3年前的牛生的牛今年会新生牛  

方法：写初始项，观察规律，分析道理

coding：可以用递归也可以从下往上写

**进阶：使用矩阵乘法可以将复杂度从 O(n) 转化为 O(logn)**

### LeetCode 64 最小路径和

**方法一：**走到根节点结算，因为有之前 **二叉树的路径和** 的经验，所以就自然这么做了。

```c++
class Solution {
public:
    void process(vector<vector<int>>& grid,int x,int y,int sum,int& min){
        if(x<grid.size()&&y<grid[0].size()){
            if(x == grid.size()-1&&y == grid[0].size()-1){
                min = sum+grid[x][y]<min? sum+grid[x][y]:min;
                return;
            }
            process(grid,x+1,y,sum+grid[x][y],min);
            process(grid,x,y+1,sum+grid[x][y],min);
        }
    }

    int minPathSum(vector<vector<int>>& grid) {
        int sum = 0;
        int min = INT_MAX;
        process(grid,0,0,sum,min);
        return min;
    }
};

int main()
{
    vector<vector<int>> grid{{6,5,3,3,7,9,6,8,1,4,8,3},{7,6,6,9,8,6,7,5,3,0,9,8},{7,0,6,9,9,0,3,7,7,9,1,7},{8,9,5,2,3,5,5,2,2,2,3,2},{0,0,8,5,0,9,6,8,0,2,9,9},{2,4,7,2,5,0,9,4,9,6,8,4},{2,3,6,6,7,0,8,0,0,6,7,3},{6,3,3,8,6,2,7,0,8,6,2,4},{6,1,0,7,0,8,1,2,3,0,0,1},{0,0,1,2,9,0,5,5,4,8,5,0},{2,2,2,1,1,5,7,9,8,7,7,8},{5,0,2,8,0,4,1,2,5,4,7,4},{5,2,1,9,3,6,1,5,0,3,8,1}};
    Solution s;
    cout<<s.minPathSum(grid)<<endl;
    return 0;
}
```

**方法二：**二叉树的递归中的另外一种做法，从左右子树得到信息，处理后返回。

```c++
class Solution {
public:
    int process(vector<vector<int>>& grid,int x,int y){
        if(x == grid.size()-1&&y == grid[0].size()-1){
            return grid[x][y];
        }
        if(x == grid.size()-1){
            return grid[x][y]+process(grid,x,y+1);
        }
        if(y == grid[0].size()-1){
            return grid[x][y]+process(grid,x+1,y);
        }
        int left = process(grid,x,y+1);
        int down = process(grid,x+1,y);
        return grid[x][y]+min(left,down);
    }

    int minPathSum(vector<vector<int>>& grid) {
        return process(grid,0,0);
    }
};

int main()
{
    vector<vector<int>> grid{{6,5,3,3,7,9,6,8,1,4,8,3},{7,6,6,9,8,6,7,5,3,0,9,8},{7,0,6,9,9,0,3,7,7,9,1,7},{8,9,5,2,3,5,5,2,2,2,3,2},{0,0,8,5,0,9,6,8,0,2,9,9},{2,4,7,2,5,0,9,4,9,6,8,4},{2,3,6,6,7,0,8,0,0,6,7,3},{6,3,3,8,6,2,7,0,8,6,2,4},{6,1,0,7,0,8,1,2,3,0,0,1},{0,0,1,2,9,0,5,5,4,8,5,0},{2,2,2,1,1,5,7,9,8,7,7,8},{5,0,2,8,0,4,1,2,5,4,7,4},{5,2,1,9,3,6,1,5,0,3,8,1}};
    Solution s;
    cout<<s.minPathSum(grid)<<endl;
    return 0;
}
```

**方法三：**动态规划，填表

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows,vector<int>(cols,0));
        dp[0][0] = grid[0][0];
        ///填第一行
        for(int i=1;i<cols;i++){
            dp[0][i] = dp[0][i-1]+grid[0][i];
        }
        ///填第一列
        for(int i=1;i<rows;i++){
            dp[i][0] = dp[i-1][0]+grid[i][0];
        }
        ///填其他位置
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                dp[i][j] = grid[i][j]+min(dp[i-1][j],dp[i][j-1]);
            }
        }

        return dp[rows-1][cols-1];
    }
};
```

### 数组元素累加

给定数组arr和一个整数aim，任意选择arr中的数字能不能累加到aim，返回true或者false

**方法一：**自己想的，思路和输出所有子序列一样，遍历到改元素时，包含该元素或不包含该元素

```c++
bool process(vector<int>& arr,int aim,int i){
    if(i==arr.size()){
        return false;
    }
    if(aim == arr[i]){
        return true;
    }
    int tmp=arr[i];
    return process(arr,aim,i+1)||process(arr,aim-tmp,i+1);
}

int main()
{
    vector<int> arr{4,5,2,1,3};
    cout<<process(arr,8,0)<<endl;
    return 0;
}
```

**方法二：**自己想的，动态规划，和视频课里讲的不一样，他讲的我没听懂。是由方法一的递归改过来的

```c++
bool process(vector<int>& arr,int aim){
    int sum = 0;
    for(int i:arr){
        sum+=i;
    }
    int rows = arr.size();
    vector<vector<bool>> dp(rows,vector<bool>(sum+1,false));
    ///填最后一行
    dp[rows-1][arr[rows-1]] = true;
    ///填其它行
    for(int i=rows-2;i>=0;i--){
        for(int j=0;j<sum;j++){
            dp[i][j] = dp[i+1][j] || (j-arr[i]>=0? dp[i+1][j-arr[i]]:false);
        }
    }
    return dp[0][aim];
}

int main()
{
    vector<int> arr{4,5,2,1,3};
    cout<<process(arr,8)<<endl;
    return 0;
}
```

# 进阶班第一课

## KMP算法
**1. 问题描述**

解决的问题与C++标准库函数中的find相同，原字符串中如果有目标字符串，返回匹配的第一个序号。

**2. 算法思路**

**重要概念：** 原字符串的next数组。一维数组，长度为原字符串的长度，内容为原字符串中每个字符匹配的前缀和后缀的最大长度。前缀和后缀的概念见下例：
以 abcabcd 为例，讨论字符d 的前缀和后缀。长度为1的前缀是a，后缀是c，不相等；长度为2的前缀是ab，后缀是bc，不相等；长度为3的前缀是abc，后缀也是abc，相等；长度为4的前缀是abca，后缀也是cabc，不相等；长度为5的前缀是abcab，后缀也是bcabc，不相等；长度为6的前缀为abcabc，后缀也为abcabc，肯定一样，没有讨论的必要，所以规定前缀不包含字符前的最后一个字符，后缀不包含第一个字符。

有了这个辅助数组，kmp算法就可以改进之前的暴力搜索，但我们也看到想得到辅助数组看起来也很复杂。

一个巧妙的地方是，后一个字符的最长匹配前后缀可以由前一个字符的最长匹配前后缀得到。

以ababcababak为例，
第0个字符a的最长匹配前后缀长度默认为 -1
第1个字符b的最长匹配前后缀长度默认为 0
字符k在它前一个字符a的基础上，a的最长匹配前缀长度为4，但a的最长前缀的下一个字符c不等于a，继续往前看c的最长前缀的下一个字符，是a，+1得到k的最长匹配前缀长度。



有了next数组，匹配过程如下例：

**i1:** 0 1 2 3 4 5 6

**s:  ** a  b k a b k s

**i2:** 0 1 2 3 4 5 6

**t: **  a  b k a b k t

s为原字符串，t为目标字符串。匹配过程开始，当 **i1 == 6，i2 == 6** 时，出现不匹配，此时不用在从头开始比，i2跳转到 **i2 == 3** 即可。

**代码**

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;
```

```cpp
///最长匹配前后缀数组
///只要记得每一个字符的最长匹配前后缀长度由它之前的字符得到就可以了
vector<int> getNextArray(string str)
{
    if(str.size()==1){
        return vector<int>{-1};
    }

    vector<int> next(str.size(),0);
    next[0]=-1;   ///默认0字符最长匹配长度为-1
    next[1]=0;    ///1字符最长匹配长度为0
    int i=2;      ///从2字符开始
    int cn=0;  ///既是前一个字符的最长前缀的长度，也是前一个字符最长前缀的后一个字符的序号，每次更新

    while(i<next.size()){
        if(str[i-1]==str[cn]){
            next[i++] = ++cn;
        }else if(cn>0){
            cn=next[cn];
        }else{
            next[i++]=0;
        }
    }
    return next;
}
```

```cpp
int getIndexOf(string s,string m){
    ///m为空，或者m的长度大于s，返回-1
    if(m.empty()||s.size()<m.size()){
        return -1;
    }
    int i1=0;  ///s从0字符开始
    int i2=0;  ///m也从0字符开始
    vector<int> next=getNextArray(m);  //得到m的next数组
    while(i1<s.size()&&i2<m.size()){   
        if(s[i1]==m[i2]){
            i1++;
            i2++;
        }else if(i2>0){
            i2=next[i2];
        }else{
            i1++;
        }
    }
    return i2==m.size()? i1-i2:-1;
}
```

```cpp
int main()
{
    string s{"abcabcde"};
    string m{"abcd"};

    cout<<getIndexOf(s,m)<<endl;

    return 0;
}
```

### 双倍字符串

给字符串末尾添加最小的字符使其包含两个原字符串。例如，abcabc，添加abc，成为 abcabcabc ，包含两个原字符串。

**解题思路：** 本题考查 next数组，求尾元素下一个元素的 最长匹配前后缀长度

### 树的包含判断

两棵二叉树 t1 和 t2 ，判断 t2 是不是 t1 的某棵子树。返回 true 或 false

**解题思路：**把两棵树序列化，如果 s2 是 s1 的子串， t2 就是 t1 的子树

### LeetCode 459 重复的子字符串

**解题思路：** 本题也考察next数组，求尾元素下一个元素的 最长匹配前后缀长度。如果 next[str.size()] 大于str.size()-next[str.size()] ，并且可以整除 str.size()-next[str.size()] ，则返回 true。

```c++
class Solution {
public:
    bool getNextArray(string str){
        if(str.size() == 1){
            return false;
        }
        vector<int> next(str.size()+1,-1);
        next[1] = 0;
        int i = 2;
        int cn = 0;
        
        while(i<next.size()){
            if(str[i-1] == str[cn]){
                next[i++] = ++cn;
            }else if(cn>0){
                cn = next[cn];
            }else{
                next[i++] = 0;
            }
        }

        int a = next[str.size()];
        int b = str.size()-next[str.size()];

        return   a<b? false:next[str.size()]%(str.size()-next[str.size()])==0;
    }

    bool repeatedSubstringPattern(string s) {
        return getNextArray(s);
    }
};
```

### LeetCode214 最短回文串

**题目描述：** 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
**解题思路：**

![](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/4.jpg)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> getNextArray(string str){
    if(str.size()==1){
        return vector<int>{-1};
    }
    vector<int> next(str.size(),-1);
    next[1] = 0;
    int i=2;
    int cn=0;
    while(i<next.size()){
        if(str[i-1] == str[cn]){
            next[i++] = ++cn;
        }else if(cn>0){
            cn = next[cn];
        }else{
            next[i++] = 0;
        }
    }
    return next;
}

int getIndexOf(string s,string t){
    int i1 = 0;
    int i2 = 0;
    vector<int> next = getNextArray(t);
    while(i1<s.size()){
        if(s[i1] == t[i2]){
            i1++;
            i2++;
        }else if(i2>0){
            i2 = next[i2];
        }else{
            i1++;
            cout<<i1<<endl;
        }
    }
    return i2;
}

string shortestPalindrome(string s) {
    if(s.empty()){
        return "";
    }
    string str(s);
    reverse(str.begin(),str.end());
    int i = getIndexOf(str,s);
    return str.substr(0,str.size()-i)+s;
}

int main()
{
    string s{"aacecaaa"};
    cout<<shortestPalindrome(s)<<endl;
    return 0;
}
```

# 进阶班第二课

## Manacher算法

**问题描述** 

寻找字符串中的最大回文子串

**算法思路**

回文半径数组、最右回文半径(回文右边界) R、回文右边界对应的回文中心 C。
只要回文右边界R不变，C就不变，C记录最早到达该回文右边界的位置
**求解过程：**
以字符串 121 为例，#1#2#1#  
最开始回文右边界为 R= -1，
0位置字符 # 在回文右边界之外，暴力扩，只有它自己，R=0，C=0
1位置字符 1 在回文右边界之外，暴力扩，R=2，C=1
2位置字符 # 在回文右边界之中，判断其对称字符的回文半径与回文左边界的关系

1. 完全在回文左边界中，其回文半径与其对称字符相同。
以下图为例，i 在C的回文右边界中，其对称字符 i‘的回文半径完全在回文左边界中，i’ 的回文半径如（）所示，由于对称原因，i 在（）内也回文。由于X' ≠ Y' （因为其在 i' 的回文半径之外），X' =X，Y'=Y，所以X≠Y，i 的回文半径与 i' 相同。

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/5.jpg)

2. 在回文左边界之外，其回文半径为到R的距离

3. 刚好压在回文左边界，未知，暴力扩。

   代码和讲的略有区别，但只是为了减少代码量做的优化。

   ```c++
   ///给原字符串插#号，方便偶回文的处理
   ///方法1
   string manacherString(string str){
       string res(str.size()*2+1,'#');
       int index = 0;
       for(int i=1;i<res.size();i+=2){
           res[i] = str[index++];
       }
       return res;
   }
   ///方法2，视频课中的方法
   string manacherString2(string str){
       string res(str.size()*2+1,' ');
       int index = 0;
       for(int i=0;i<res.size();i++){
           res[i] = (i&1)==0? '#':str[index++];
       }
       return res;
   }
   
   int maxLcpsLength(string str){
       if(str.empty()){
           return 0;
       }
       string mstr = manacherString(str);
       vector<int> array(mstr.size(),0); //回文半径数组
       int C=-1; //回文中心
       int R=-1; //回文右边界
       int Max = INT_MIN; //记录最长的回文长度
       ///填充回文半径数组
       for(int i=0;i<array.size();i++){
           array[i] = R>i ? min(array[2*C-i],R-i):1;
           while(i+array[i]<array.size()&&i-array[i]>-1){
               if(mstr[i+array[i]] == mstr[i-array[i]]){
                   array[i]++;
               }else{
                   break;
               }
           }
           if(i+array[i]>R){
               R = i+array[i];
               C = i;
           }
           Max = max(Max,array[i]);
       }
       return Max-1;
   }
   ```

### LeetCode 5 最长回文子串

修改manacher算法即可，记录最长的  array[i]

上面manacher算法的边界条件似乎有问题，LeetCode上过不了，下面的代码没问题。区别在于上面的代码，R指向边界之外，下面的代码R指向边界。

```c++
class Solution {
public:
    string manacherString(string str){
        string res(str.size()*2+1,'#');
        int index = 0;
        for(int i=1;i<res.size();i+=2){
            res[i] = str[index++];
        }
        return res;
    }
    
    string longestPalindrome(string s) {
        if (s.size() < 2) {
            return s;
        }
        // 得到预处理字符串
        string str = manacherString(s);
        // 数组 p 记录了扫描过的回文子串的信息
        vector<int> p(str.size(), 0);

        // 双指针，它们是一一对应的，须同时更新
        int R = -1;
        int C = -1;

        int Max = 1;
        int start = 0;

        for (int i = 0; i < str.size(); ++i) {
            p[i] = R<i? 0:min(R-i,p[2*C-i]);

            while ((i - (1 + p[i])) >= 0 && (i + (1 + p[i])) < str.size()) {
                if(str[i - (1 + p[i])] == str[i + (1 + p[i])]){
                    p[i]++;
                }else{
                    break;
                }
            }

            if (i + p[i] > R) {
                R = i + p[i];
                C = i;
            }
            if (p[i] > Max) {
                Max = p[i];
                start = (i - Max) / 2;
            }
        }
        return s.substr(start, Max);
    }
};
```

### LeetCode 214  最短回文串

```
class Solution {
public:
    string manacherString(string s){
        string str(s.size()*2+1,'#');
        int index = 0;
        for(int i=1;i<str.size();i+=2){
            str[i] = s[index++];
        }
        return str;
    }
    string shortestPalindrome(string s) {
        if(s.size()<2){
            return s;
        }
        string rs = s;
        reverse(rs.begin(),rs.end());
        string str = manacherString(rs);
        vector<int> p(str.size(),0);
        int R = -1;
        int C = -1;

        for(int i=0;i<str.size();i++){
            p[i] = R<i? 0:min(R-i,p[2*C-i]);
            while((i-(1+p[i])>-1)&&(i+(1+p[i])<str.size())){
                if(str[i-(1+p[i])]==str[i+1+p[i]]){
                    p[i]++;
                }else{
                    break;
                }
            }
            if(i+p[i]>R){
                R=i+p[i];
                C=i;
            }
            if(R==str.size()-1){
                break;
            }
        }

        return rs.substr(0,s.size()-R+C)+s;
    }
};
```

 ## BFPRT算法
**问题描述**

 在无序数组中找到第k小或第k大的数。

**算法思路**

 1、第一种方法，排序，O(nlogn)的复杂度
 2、第二种方法，采用荷兰国旗问题的思路，随机选取一个数，把所有数据分成三份，小于该数的，等于该数的和大于该数的。例如要寻找第200小的数，我随机选取一个数，发现等于区域是 500-600，那么在对 小于区域进行划分，直到找到第k小的数。时间复杂度取决于划分值的选取，长期期望是 O(n)
 3、第三种方法，BFPRT算法，改进了第二种方法划分值的选择。
 bfprt(arr，k)
第一步：分组 每5个数分一组
第二步：小组之间排序  5个数排 时间复杂度O(1)，n/5 组，时间复杂度 O(n/5)，O(n)
第三步：拿出每个数组的中位数，组成一个新的数组 长度 n/5  new_arr
第四步：递归调用 bfprt 算法， bfprt(new_arr，new_arr.size()/2)
用第四步找到的中位数作为partition算法的划分值。

没有代码，一般这种题用 堆比较多，但复杂度是 O(n*logn)

## 窗口

窗口内最大值或最小值的更新情况（单调双向队列）
一开始 L、R都指向数组的左侧，R向右移动窗口进数，L向右移动窗口出数。L和R都只能向右走，且L不能移动到R的右侧。

![题目描述](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/15.png)

如何在窗口更新的时候得到窗口中的最大值或最小值，当然可以每次遍历，但更好的方法是使用双端队列结构。

如果是要得到最大值，就使双向队列中的数从头到尾从大到小排列，不能相等，相等也要弹出

![](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/16.png)



我们从L、R都在最左侧开始，逐步移动R，以 1234321 为例，
规则：
1. 当新遍历序号的value大于等于双端队列尾部序号的value时，尾部弹出，直到新遍历序号的value小于双端队列尾部序号的value时，从尾部压入新遍历的序号。

   ```cpp
   #include <iostream>
   #include <queue>
   
   using namespace std;
   
   ///得到窗口中的最大值数组
   ///窗口的大小是 w
   vector<int> getMaxWindow(vector<int>& arr,int w){
       if(arr.empty()||w<1||arr.size()<w){
           return vector<int>();
       }
   
       deque<int> qmax; ///双端队列
       vector<int> res(arr.size()-w+1,0); ///存储每个窗口的最大值
   
       int index=0;
       ///i是R的位置，i-w是L的位置
       for(int i=0;i<arr.size();++i){
           while(!qmax.empty()&&arr[qmax.back()]<=arr[i]){
               qmax.pop_back();
           }
           qmax.push_back(i);
           ///加入一个值，并且此时双端队列的头部即最大值的序号等于L时，弹出
           ///i-w是每次增1，不可能会跳过之前压入的序号，
           ///所以之前压入的序号要么会等于 i-w，
           ///要么i-w已经因为比较小被弹出
           if(qmax.front()==i-w){
               qmax.pop_front();
           }
           ///从i+1等于w开始，为结果的数组添加数，例如如果w是3，当R为2时，窗口中满3个数，就要得到第一个最大值
           ///以后R每前进一个，L前进一个，窗口更新，加入新窗口的最大值
           if(i>=w-1){
               res[index++]=arr[qmax.front()];
           }
       }
       return res;
   }
   
   
   int main()
   {
       vector<int> v{1,2,3,4,3,2,1};
       vector<int> ans=getMaxWindow(v,3);
       for(int i:ans){
           cout<<i<<" ";
       }
       cout<<endl;
       return 0;
   }
   ```

   ### LeetCode 剑指offer 59-1 滑动窗口的最大值

   代码同上

   ```c++
   class Solution {
   public:
       vector<int> maxSlidingWindow(vector<int>& nums, int k) {
           //vector<int> res(nums.size()-k+1,0);
           vector<int> res;
           deque<int> win;
   
           ///遍历数组
           for(int i=0;i<nums.size();i++){
               while(!win.empty()&&nums[i]>=nums[win.back()]){
                   win.pop_back();
               }
               win.push_back(i);
               if(win.front()==i-k){
                   win.pop_front();
               }
               if(i+1>=k){
                   res.push_back(nums[win.front()]);
               }
           }
           return res;
       }
   };
   ```

   ### 最大值减去最小值小于等于num的子数组的数量

   **基本原理：** 如果一个子数组满足，那么它的子数组一定都满足；如果一个子数组不满足，那么包含它的子数组一定不满足
   **算法流程：** 
   **代码**

   ```cpp
   #include <iostream>
   #include <queue>
   
   using namespace std;
   
   int getNum(vector<int>& arr,int num){
       if(arr.empty()){
           return  0;
       }
       deque<int> qmin;  ///更新窗口最小值
       deque<int> qmax;  ///更新窗口最大值
       int L=0;
       int R=0;
       int res=0;
   
       while(L<arr.size()){
           while(R<arr.size()){
               while(!qmin.empty()&&arr[qmin.back()]>=arr[R]){
                   qmin.pop_back();
               }
               qmin.push_back(R);
               while(!qmax.empty()&&arr[qmax.back()]<=arr[R]){
                   qmax.pop_back();
               }
               qmax.push_back(R);
               if(arr[qmax.front()]-arr[qmin.front()]>num){
                   break;
               }
               R++;
           }
           if(qmin.front()==L){
               qmin.pop_front();
           }
           if(qmax.front()==L){
               qmax.pop_front();
           }
           res+=R-L;  ///以L开头的符合条件的所有子数组
           L++;
       }
       return res;
   }
   
   
   int main()
   {
       vector<int> nums{1,4,8,2,6,9,22,13};
       cout<<getNum(nums,10)<<endl;
       return 0;
   }
   ```

## 单调栈

寻找一个数组中每个数左边离它最近的比它大的和右边离它最近的比它大的数

**算法思路：** 

维持一个栈，栈中数据从栈底到栈顶由大到小，以数组 5 4 3 6 为例，5入栈，4入栈，3入栈，到 6 入栈时，发现栈顶元素 3 比它小，3 弹出，并可知 3 的右侧离它最近的比它大的数时6，3 在栈中下面的数是 4 ，是左边离它最近的比它大的数。
3 左边离它最近比它大的数是 4，右边是 6
接着判断，6>4，4 弹出
4 左边离它最近比它大的数是 5，右边是 6
6>5，5 弹出
5 左边离它最近比它大的数是 null，右边是 6
6入栈
6因为到数组结尾了，弹出，不是因为由数据比它大入栈弹出，所以右边离它最近比它大的数是null，左边离它最近的比它大的数是它在栈中下面的数，也是 null

![](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/17.png)

特殊情况，如果数组中有连续的相同的数，例如 5 5 5 5 5，连同序号压在一起。
0号5入栈，轮到1号5，不能直接压在0号5上面，因为它下面的5，不是左边离它最近的比它大的，也不能弹出0号5，因为1号5不是右边离它最近的比它大的。压在一起，这样我们之前的规则还适用

![](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/18.png)

### LeetCode 84 柱状图中的最大矩形

例如，数组 1 2 3 2 4 5，如图，最大面积是阴影部分，10

![](https://github.com/JZZ-NOTE/Algorithm/raw/main/picture/7.jpg)

**算法思路：**
从每一个位置往两边扩，遇到比自己小的停止。
即寻找左右离自己最近的比自己小的数，可以用单调栈来做。

举例体会 当元素相等时会发生什么，答案是相等元素的最后一个会得到正确的面积。

**代码**

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

///求直方图中的最大面积
int maxRecFromBottom(vector<int>& height){
    if(height.empty()){
        return 0;
    }
    int maxArea = 0;
    stack<int> stack;
    for(int i=0;i<height.size();++i){
        while(!stack.empty()&&height[i]<=height[stack.top()]){
            int j=stack.top();
            stack.pop();
            int k=stack.empty()?-1:stack.top();
            int curArea= (i-k-1)*height[j];
            maxArea=max(maxArea,curArea);
        }
        stack.push(i);
    }
    while(!stack.empty()){
        int j=stack.top();
        stack.pop();
        int k=stack.empty()? -1:stack.top();
        int curArea=(height.size()-k-1)*height[j];
        maxArea = max(maxArea,curArea);
    }
    return maxArea;
}

int main()
{
    vector<int> nums{1,2,3,2,4,5};
    cout<<maxRecFromBottom(nums)<<endl;
    return 0;
}
```

###  LeetCode 85 最大矩形

```c++
给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩阵区域中，最大的全是1的矩形区域中1的数量。
例如：
1 1 1 0
其中，最大的矩形区域有3个1，所有返回3。
再如：
1 0 1 1
1 1 1 1
1 1 1 0
其中，最大的矩形区域有6个1，所以返回6。
```
这道题可以用上一道题衍生而来，依次寻找以每一行为底的直方图的最大面积。以第i行为底的直方图数组可以由 i-1 行得到，如果第 i 行该位置是 1，则在第 i-1 行的基础上加 1，如果第 i 行该位置是0，则为 0。
```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    int maxRecFormBottom(vector<int>& heights){
        if(heights.empty()){
            return 0;
        }
        stack<int> stack;
        int maxArea = 0;
        for(int i=0;i<heights.size();i++){
            while(!stack.empty()&&heights[i]<=heights[stack.top()]){
                int j=stack.top();
                stack.pop();
                int k= stack.empty()?-1:stack.top();
                int curArea = (i-k-1)*heights[j];
                maxArea = max(maxArea,curArea);
            }
            stack.push(i);
        }
        while(!stack.empty()){
            int j=stack.top();
            stack.pop();
            int k= stack.empty()?-1:stack.top();
            int curArea = (heights.size()-k-1)*heights[j];
            maxArea = max(maxArea,curArea);
        }
        return maxArea;
    }

    int maximalRectangle(vector<vector<char>>& map){
        if(map.empty()||map[0].empty()){
            return 0;
        }
        int rows = map.size();
        int cols = map[0].size();
        vector<int> heights(cols,0);
        int maxArea=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                heights[j] = map[i][j]=='1'?heights[j]+1:0;
            }
            int curArea = maxRecFormBottom(heights);
            maxArea = max(maxArea,curArea);
        }
        return maxArea;
    }
};

int main()
{
    vector<vector<char>> map{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}};
    Solution s;
    cout<<s.maximalRectangle(map)<<endl;
    return 0;
}
```

### 环形山可见问题

```c++
给定一个数组形成一个环形山脉，如图 数组 1 2 4 5 3 组成一个环形山脉，输出可互相看见的山的对数。两座山满足如下条件可互相看见：
（1）相邻。相邻的两座山可以互相看见
（2）两座不相邻的山如果两座山之间没有比两座山较矮的山高的山，可互相看见
（3）可以有两个方向，顺时针或逆时针
例如，示例中可见的山峰对有7对：
[1 2] [1 3] 
[2 3] [2 4] 
[3 4] [3 5]
[4 5]
```

```c++
如果山峰的高度中没有相同的值，那么答案只与山峰的总数有关，有 2*n - 3 对
为了不重复统计，我们人为规定 矮的山去比自己高的山。
在大于3个数的数组中，总有一个最高山和次高山，它俩之间的数，找比自己大的可见山一定有2个（向两边找离自己最近的比自己大的数，后面的肯定看不到了），假设总共有 n座山，除最高与此高，还有 n-2 座山峰，每个有两对，共有 (n-2) * 2 对，再加上最高与次高这一对，有 2 * n - 3 对
如果有想相同的值就不一定了，因为 没座山在最高和次高之间除了第一个比自己高的，还可以看到同高的山。
```

```c++
算法思路：从全局最大开始遍历，如果有多个，从第一个全局最大开始。压栈，碰到比自己大的出栈，相同的数次数压在一起
```

```c++
#include <vector>
#include <stack>
#include <iostream>

using namespace std;

///实现序号的循环
int nextIndex(int size,int index){
    return index<size-1? ++index:0;
}

///计算C(n,2)
long getInternalSum(int n){
    return n==1?0:(long)n*(long)(n-1)/2;
}

long communications(vector<int>& arr){
    if(arr.size()<2){
        return 0;
    }
    int size=arr.size();
    int maxIndex=0;
    ///遍历一遍数组，找到最大值的第一个序号
    for(int i=0;i<size;++i){
        maxIndex= arr[maxIndex]<arr[i]? i:maxIndex;
    }
    ///最大值
    int value=arr[maxIndex];
    ///最大值的下一个序号
    int index=nextIndex(size,maxIndex);
    long res=0;
    ///栈中压入值和次数 first->value,second->times
    stack<pair<int,int>> stack;
    ///最大值入栈
    stack.push(pair<int,int>(value,1));
    ///如果序号转圈又回到最大值，说明遍历完一遍了，结束遍历
    while(index!=maxIndex){
        value=arr[index];
        while(!stack.empty()&&stack.top().first<value){
            int times=stack.top().second;  ///读出栈顶的 times
            stack.pop(); ///栈顶弹出
            res+=getInternalSum(times)+2*times;  ///C(n,2)+2*n,
            ///这里还不需要考虑特殊情况，因为栈里此时最少有两个值，或者有多个最大值
        }
        if(!stack.empty()&&stack.top().first==value){
            stack.top().second++;
        }else{
            stack.push(pair<int,int>(value,1));
        }
        index = nextIndex(size,index);
    }
    while(!stack.empty()){
        int times=stack.top().second;
        stack.pop();
        res+=getInternalSum(times);
        if(!stack.empty()){
            res+=times;
            if(stack.size()>1){
                res+=times;
            }else{
                res+=stack.top().second>1?times:0;
            }
        }
    }
    return res;
}

int main()
{
    vector<int> arr{1,2,4,5,3};
    cout<<communications(arr)<<endl;
    return 0;
}
```

# 进阶班第三课

## 二叉树的Morris遍历

时间复杂度O(n)，额外空间复杂度O(1)的二叉树的遍历方式。在二叉树正常的遍历中，会有O(h)的额外空间复杂度，h是二叉树的高度，原因是二叉树没有指向父节点的指针，因此为了回退，需要在栈中压入父节点的信息。

morris遍历  利用叶子节点的空孩子完成返回上级的操作（线索二叉树）

```c++
来到当前节点，记为cur
1.如果cur无左孩子，cur向右移动（cur=cur->right）
2.如果cur有左孩子，找到cur左子树上最右的节点，记为mostright
  (1)如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur->left）
  (2)如果mostright的right指针指向cur,让其指向空，cur向右移动
```

```cpp
#include <iostream>
using namespace std;

struct Node{
    int val;
    Node* left=nullptr;
    Node* right=nullptr;
    Node(int _val,Node* _left=nullptr,Node* _right=nullptr):val(_val),left(_left),right(_right){ }
};

void morrisIn(Node* head){
    if(head==nullptr){
        return;
    }
    Node* cur=head;
    Node* mostRight=nullptr;
    while(cur!=nullptr){
        mostRight=cur->left;
        if(mostRight!=nullptr){
            ///找到左子树的最右节点，最右节点可能有两种情况
            ///没有处理过，指向空
            ///处理过，指向cur
            while(mostRight->right!=nullptr&&mostRight->right!=cur){
                mostRight=mostRight->right;
            }
            if(mostRight->right==nullptr){
                mostRight->right=cur;
                cur=cur->left;
                continue;
            }else{
                mostRight->right=nullptr;
            }
        }
        cout<<cur->val<<endl;
        cur=cur->right;
    }
}

int main()
{
    Node node4(4,nullptr,nullptr);
    Node node5(5,nullptr,nullptr);
    Node node6(6,nullptr,nullptr);
    Node node7(7,nullptr,nullptr);
    Node node2(2,&node4,&node5);
    Node node3(3,&node6,&node7);
    Node node1(1,&node2,&node3);

    morrisIn(&node1);
    return 0;
}
```

在morris遍历中，只要一个节点有左子树，就能回到这个节点两次，如果一个节点没有左子树，只到达这个节点一次。当我第二次到达这个节点时，左子树的所有节点都遍历过了。根据左子树的最右节点的状态来标记是第几次回到该节点，如果指向空说明是第一次，并令其指向cur，如果指向cur，说明是第二次，左侧遍历结束，开始往右走

# 进阶班第四课

## 搜索二叉树

搜索二叉树：在一棵树中，任意一个节点，左子树的值都比自己小，右子树的值都比自己大。相同的值可以压在一起。
搜索二叉树的中序遍历是升序的
搜索二叉树相对于哈希表因为多了排序的属性，所以可以做更多的事情

搜索二叉树查找、插入、删除的时间复杂度与树的高度有关，同样的数据可以组织成不同的二叉树，但当其高度越小时处理效率越高，平衡搜索二叉树就是一种高度平衡的二叉树，为了形成一棵平衡搜索二叉树，就需要在插入、删除的过程中调整节点的顺序。
**AVL树：** 以任何一个节点为根的子树，左右子树的高度差不超过1。条件较为严苛，所做的调整就要较为频繁。
**红黑树：** 有自己的标准。 根节点涂黑，叶结点涂黑，从根节点到每个叶子节点的路径中黑色节点数量相当，不能有两个相邻的红色节点。在这样的标准下，最长链的长度不会大于最短链长度的两倍。
**SB树：** 以叔叔节点为根的树的总节点不少于子侄节点

**二叉搜索树的操作**
1、查找
2、添加
3、删除：二叉搜索树的查找和添加都比较容易，找到对应的位置即可。删除比较复杂，分几种情况：
1. 要删除的节点没有左子树或没有右子树，直接用右孩子或者左孩子替换它
2. 要删除的既有左子树又有右子树，使用右子树的最左节点替换，最左节点如果有右子树，挂在其父节点下。（使用比它大的值中的最小值替换，或者使用比它小的值中的最大值替换--左子树的最右节点）

如果要兼顾平衡性，还要在操作时进行其它操作，基本操作有两种，左旋、右旋，不同的平衡搜索二叉树所要做的操作是两种基本操作的不同组合。
**右旋**
顺时针旋转又称右旋，旋转的结果是 右孩子成为根，旋转的细节如下图所示：

