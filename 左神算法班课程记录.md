# 第一课

[递归] 01:05:36

[递归行为复杂度分析] 01:04:00   

[小和问题和逆序对问题] 00:25:50

## 认识时间复杂度

## 递归

1. 递归与普通的函数调用没有区别，只不过是每次调用的子函数相同。
2. 函数调用时会发生压栈的行为，记录父函数即将执行的指令位置及参数状态，子函数返回时，弹出要执行的指令位置及参数状态。
3. 递归最终要能够返回，要有终止的状态。

### 递归复杂度分析

T(N) = aT(N/b) + O(N^d)

上式的含义是：样本量为N时，时间复杂度为 T(N)，处理时将 N 的样本量分为 a个 N/b 的处理，各段处理完之后，需要 O(N^d) 的处理。

满足上式的情况时间复杂度为（master公式）：

1. log(b,a) > d ，复杂度为 O(N^log(b,a))
2. log(b,a) = d，复杂度为  O(N^d*logN)
3. log(b,a) < d，复杂度为  O(N^d)

### 递归实现返回数组最大值

**思路是**：将一个数组分成两段，分别得到两段的最大值，再比较返回较大的那一个。

```c++
#include <vector>
#include <iostream>
using namespace std;

int myMax(vector<int>& arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L+((R-L)>>1);
    int mL= myMax(arr,L,mid);
    int mR= myMax(arr,mid+1,R);
    return mL>mR? mL:mR;
}

int main()
{
    vector<int> arr{1,4,2,6,5,8,9,7};
    int arrMax=myMax(arr,0,arr.size()-1);
    cout<<arrMax<<endl;
    return 0;
}
```

T(N) = aT(N/b) + O(1)

log(b,a) = 1> d =0

时间复杂度：N

### 归并排序

**思路是**：将一个数组分成两段，将两段分别排序，再合并两个有序数组。

```c++
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr,int L,int mid,int R){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }

    while(p1<=mid){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }

    for(int j=L;j<=R;++j){
        arr[j]=help[j-L];
    }
}

void sortProcess(vector<int>& arr,int L,int R){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    sortProcess(arr,L,mid);
    sortProcess(arr,mid+1,R);
    merge(arr,L,mid,R);
}

void mergeSort(vector<int>& arr){
    if(arr.empty()||arr.size()==1){
        return;
    }
    sortProcess(arr,0,arr.size()-1);
}

int main()
{
    vector<int> arr{5,6,4,3,8,7,2,1};
    mergeSort(arr);
    for(int i:arr){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

**时间复杂度：** O(n*lgn)

T(N) = aT(N/b) + O(N)

log(b,a) = 1= d =1

时间复杂度：NlogN

#### 小和问题和逆序对问题

**LeetCode 剑指Offer 51 数组中的逆序对**

```c++
#include <vector>
#include <iostream>
using namespace std;

void merge(vector<int>& nums,int L,int mid,int R,int& ans){
    vector<int> help(R-L+1,0);
    int i=0;
    int p1=L;
    int p2=mid+1;
    while(p1<=mid&&p2<=R){
        if(nums[p1]>nums[p2]){
            ans+=R-p2+1;
            help[i++]=nums[p1++];
        }else{
            help[i++]=nums[p2++];
        }
    }

    while(p1<=mid){
        help[i++]=nums[p1++];
    }
    while(p2<=R){
         help[i++]=nums[p2++];
    }

    for(int j=L;j<=R;++j){
        nums[j]=help[j-L];
    }
}

void mergeSort(vector<int>& nums,int L,int R,int& ans){
    if(L==R){
        return;
    }
    int mid = L+((R-L)>>1);
    mergeSort(nums,L,mid,ans);
    mergeSort(nums,mid+1,R,ans);
    merge(nums,L,mid,R,ans);
}

int reversePairs(vector<int>& nums) {
    if(nums.size()<=1){
        return 0;
    }
    int ans=0;
    mergeSort(nums,0,nums.size()-1,ans);
    return ans;
}

int main()
{
    vector<int> nums{7,5,6,4};
    cout<<reversePairs(nums)<<endl;
    return 0;
}
```

# 第二课

## 荷兰国旗问题

给定数字 n，将数组 nums 分成三块，小于 n，等于 n，大于 n。要求额外空间复杂度 O(1)，时间复杂度 O(n)。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}
```

## 快速排序

快速排序就是使用 partition 进行递归，每次排好锚点的位置，对大于和小于锚点的部分在进行 partition，有几点需要注意：

1. 锚点使用数组的最后一个数
2. partition可以使用原来的，也可以如下进行稍微的改进，改进的作用只是节省了一个变量，差别不大。
3. 递归的终止条件是 L>=R , L=R的情况就是大于或小于锚点的部分只有一个数，不用再排序，L>R的情况是 上一次再排好锚点以后，没有大于锚点的部分或小于锚点的部分。可举例体会。

```c++
#include <iostream>
#include <vector>
using namespace std;

void swap(vector<int>& nums,int i,int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

vector<int> partition(vector<int>& nums,int L,int R,int num){
    int less=L-1;
    int more=R+1;

    while(L<more){
        if(nums[L]<num){
            swap(nums,++less,L++);
        }else if(nums[L]>num){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    return vector<int>{less,more};
}

vector<int> partition2(vector<int>& nums,int L,int R){
    int less=L-1;
    int more=R;

    while(L<more){
        if(nums[L]<nums[R]){
            swap(nums,++less,L++);
        }else if(nums[L]>nums[R]){
            swap(nums,--more,L);
        }else{
            L++;
        }
    }

    swap(nums,more,R);

    return vector<int>{less,more};
}

void quickSort(vector<int>& nums,int L,int R){
    if(L<R){
        vector<int> board(2,0);
        //board = partition(nums,L,R,nums[R]);
        board = partition2(nums,L,R);
        quickSort(nums,L,board[0]);
        quickSort(nums,board[1],R);
    }
}

int main()
{
    vector<int> nums{1,4,2,5,7,5,3};
    quickSort(nums,0,nums.size()-1);
    for(int i:nums){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```

在锚点选的比较好时，大于锚点和小于锚点的区域相当，

**时间复杂度：** O(n*lgn)

T(N) = 2T(N/2) + O(N)

log(b,a) = 1= d =1

时间复杂度：O(NlogN)

如果锚点选的不好，没有大于区域或没有小于区域，时间复杂度 O(N^2)

**改进方法是** 锚点随机选择，不再只用最后一个数。

```C++
#include <random>
void quickSort(vector<int>& nums,int L,int R){
    if(L>=R){
        return;
    }
    ///产生随机数
    std::mt19937 rng;
    rng.seed(random_device()());
    std::uniform_int_distribution<std::mt19937::result_type> dist(L,R);
    swap(nums,dist(rng),R);

    vector<int> board;
    board=partition(nums,L,R,nums[R]);
    quickSort(nums,L,board[0]);
    quickSort(nums,board[1],R);
}
```